package main

import (
  "os"
  "bytes"
  "bufio"
  "errors"
  "regexp"
  "encoding/json"
  "fmt"
  "io/ioutil"
  "log"
  "strings"
  "strconv"
  "net/http"
  //"net/http/httputil"
  //"net/url"
  "time"
  "flag"

  // SOCKS proxy (for TOR)
  "golang.org/x/net/proxy"
  
  // SQLite3 package
  "database/sql"
  //_ "github.com/mattn/go-sqlite3"
  _ "modernc.org/sqlite"
)

// ratsit api https://www.ratsit.se/api/search/person?fnamn=patrik&enamn=f%C3%A4ltstr%C3%B6m&gata=&postnr=&ort=&kn=&pnr=196505&tfn=&m=1&k=1&r=1&er=1&b=1&eb=1&amin=16&amax=120&fon=1&typ=2&page=1

type RatsitAutogenerated struct {
	Company struct {
		Hits []struct {
			CompanyName    string `json:"companyName"`
			Address        string `json:"address"`
			BolagsformCode int    `json:"bolagsformCode"`
			ID             string `json:"id"`
			Coordinates    struct {
				Lat string `json:"lat"`
				Lng string `json:"lng"`
			} `json:"coordinates"`
			CompanyURL string `json:"companyUrl"`
		} `json:"hits"`
		FilterOptions struct {
			BolagsformCode []struct {
				Input    string `json:"input"`
				Text     string `json:"text"`
				Key      string `json:"key"`
				Count    int    `json:"count"`
				Selected bool   `json:"selected"`
			} `json:"bolagsformCode"`
		} `json:"filterOptions"`
		Pager struct {
			PageIndex                     int   `json:"pageIndex"`
			PageCount                     int   `json:"pageCount"`
			VisiblePages                  []int `json:"visiblePages"`
			ShowBack                      bool  `json:"showBack"`
			ShowForward                   bool  `json:"showForward"`
			ShowFirstPageShortcut         bool  `json:"showFirstPageShortcut"`
			ShowFirstPageShortcutEllipsis bool  `json:"showFirstPageShortcutEllipsis"`
			ShowLastPageShortcut          bool  `json:"showLastPageShortcut"`
			ShowLastPageShortcutEllipsis  bool  `json:"showLastPageShortcutEllipsis"`
			AreMorePagesAvailable         bool  `json:"areMorePagesAvailable"`
		} `json:"pager"`
		TotalHits int `json:"totalHits"`
	} `json:"company"`
	Person struct {
		Hits []struct {
			Hidden                  bool   `json:"hidden"`
			ID                      string `json:"id"`
			FirstName               string `json:"firstName"`
			LastName                string `json:"lastName"`
			GivenName               string `json:"givenName"`
			Age                     int    `json:"age"`
			StreetAddress           string `json:"streetAddress"`
			City                    string `json:"city"`
			Married                 bool   `json:"married"`
			Gender                  string `json:"gender"`
			HasCorporateEngagements bool   `json:"hasCorporateEngagements"`
			Coordinates             struct {
				Lat string `json:"lat"`
				Lng string `json:"lng"`
			} `json:"coordinates"`
			PersonURL     string `json:"personUrl"`
			LoneKollenURL string `json:"loneKollenUrl"`
		} `json:"hits"`
		FilterOptions struct {
			Gender []struct {
				Input    string `json:"input"`
				Text     string `json:"text"`
				Key      string `json:"key"`
				Count    int    `json:"count"`
				Selected bool   `json:"selected"`
			} `json:"gender"`
			CorporateEngagements []struct {
				Input    string `json:"input"`
				Text     string `json:"text"`
				Key      string `json:"key"`
				Count    int    `json:"count"`
				Selected bool   `json:"selected"`
			} `json:"corporateEngagements"`
			MaritalStatus []struct {
				Input    string `json:"input"`
				Text     string `json:"text"`
				Key      string `json:"key"`
				Count    int    `json:"count"`
				Selected bool   `json:"selected"`
			} `json:"maritalStatus"`
			Age []struct {
				Input    string `json:"input"`
				Text     string `json:"text"`
				Key      string `json:"key"`
				Count    int    `json:"count"`
				Selected bool   `json:"selected"`
			} `json:"age"`
		} `json:"filterOptions"`
		Pager struct {
			PageIndex                     int   `json:"pageIndex"`
			PageCount                     int   `json:"pageCount"`
			VisiblePages                  []int `json:"visiblePages"`
			ShowBack                      bool  `json:"showBack"`
			ShowForward                   bool  `json:"showForward"`
			ShowFirstPageShortcut         bool  `json:"showFirstPageShortcut"`
			ShowFirstPageShortcutEllipsis bool  `json:"showFirstPageShortcutEllipsis"`
			ShowLastPageShortcut          bool  `json:"showLastPageShortcut"`
			ShowLastPageShortcutEllipsis  bool  `json:"showLastPageShortcutEllipsis"`
			AreMorePagesAvailable         bool  `json:"areMorePagesAvailable"`
		} `json:"pager"`
		TotalHits int `json:"totalHits"`
	} `json:"person"`
}

// type RatsitAutogenerated struct {
//   Snabbsok  bool        `json:"snabbSok"`
//   Text      interface{} `json:"text"`
//   Vemvarsok bool        `json:"vemVarSok"`
//   Vem       interface{} `json:"vem"`
//   Var       interface{} `json:"var"`
//   Person    struct {
//     Nysokning             bool `json:"nySokning"`
//     Visaantaltraffar      bool `json:"visaAntalTraffar"`
//     Flertraffar           bool `json:"flerTraffar"`
//     Antaltraffartotalt    int  `json:"antalTraffarTotalt"`
//     Antaltraffarbegransat bool `json:"antalTraffarBegransat"`
//     Nastatrafffran        int  `json:"nastaTraffFran"`
//     Antaldoldatraffar     int  `json:"antalDoldaTraffar"`
//     Isuservalidated       bool `json:"isUserValidated"`
//     Isuserpluscustomer    bool `json:"isUserPlusCustomer"`
//     List                  []struct {
//       Ishiddenperson        bool     `json:"isHiddenPerson"`
//       Lastnamecomplete      string   `json:"lastNameComplete"`
//       Hashiddenaddress      bool     `json:"hasHiddenAddress"`
//       Address               string   `json:"address"`
//       Postnr                string   `json:"postNr"`
//       Postort               string   `json:"postort"`
//       Isfemale              bool     `json:"isFemale"`
//       Hasrelation           bool     `json:"hasRelation"`
//       Age                   int      `json:"age"`
//       Personrapporturl      string   `json:"personrapportUrl"`
//       Givennames            []string `json:"givenNames"`
//       Names                 []string `json:"names"`
//       Hasbolagsengagemang   bool     `json:"hasBolagsengagemang"`
//       Antalbolagsengagemang int      `json:"antalBolagsengagemang"`
//     } `json:"list"`
//     Paging struct {
//       Totalpages               int         `json:"totalPages"`
//       Allowedpages             int         `json:"allowedPages"`
//       Visiblepageslowindex     int         `json:"visiblePagesLowIndex"`
//       Visiblepageshighindex    int         `json:"visiblePagesHighIndex"`
//       Pageindex                int         `json:"pageIndex"`
//       Hasnextpage              bool        `json:"hasNextPage"`
//       Haspreviouspage          bool        `json:"hasPreviousPage"`
//       Hasnextpageurl           interface{} `json:"hasNextPageUrl"`
//       Haspreviouspageurl       interface{} `json:"hasPreviousPageUrl"`
//       Showfirstshortcut        bool        `json:"showFirstShortcut"`
//       Showlastshortcut         bool        `json:"showLastShortcut"`
//       Showfirstshortcutelipsis bool        `json:"showFirstShortcutElipsis"`
//       Showlastshortcutelipsis  bool        `json:"showLastShortcutElipsis"`
//       Showloginformoremessage  bool        `json:"showLoginForMoreMessage"`
//     } `json:"paging"`
//   } `json:"person"`
//   Company struct {
//     Clientqueryid         int           `json:"clientQueryId"`
//     Nysokning             bool          `json:"nySokning"`
//     Visaantaltraffar      bool          `json:"visaAntalTraffar"`
//     Flertraffar           bool          `json:"flerTraffar"`
//     Antaltraffartotalt    int           `json:"antalTraffarTotalt"`
//     Antaltraffarbegransat bool          `json:"antalTraffarBegransat"`
//     Nastatrafffran        int           `json:"nastaTraffFran"`
//     List                  []interface{} `json:"list"`
//     Paging                struct {
//       Totalpages               int         `json:"totalPages"`
//       Allowedpages             int         `json:"allowedPages"`
//       Visiblepageslowindex     int         `json:"visiblePagesLowIndex"`
//       Visiblepageshighindex    int         `json:"visiblePagesHighIndex"`
//       Pageindex                int         `json:"pageIndex"`
//       Hasnextpage              bool        `json:"hasNextPage"`
//       Haspreviouspage          bool        `json:"hasPreviousPage"`
//       Hasnextpageurl           interface{} `json:"hasNextPageUrl"`
//       Haspreviouspageurl       interface{} `json:"hasPreviousPageUrl"`
//       Showfirstshortcut        bool        `json:"showFirstShortcut"`
//       Showlastshortcut         bool        `json:"showLastShortcut"`
//       Showfirstshortcutelipsis bool        `json:"showFirstShortcutElipsis"`
//       Showlastshortcutelipsis  bool        `json:"showLastShortcutElipsis"`
//       Showloginformoremessage  bool        `json:"showLoginForMoreMessage"`
//     } `json:"paging"`
//   } `json:"company"`
//   Personfilter struct {
//     Page                  int         `json:"page"`
//     Typ                   int         `json:"typ"`
//     Clientqueryid         int         `json:"clientQueryId"`
//     Trafffran             int         `json:"traffFran"`
//     Vem                   interface{} `json:"vem"`
//     Var                   interface{} `json:"var"`
//     Pnr                   string      `json:"pNr"`
//     Fnamn                 interface{} `json:"fNamn"`
//     Tnamn                 interface{} `json:"tNamn"`
//     Enamn                 interface{} `json:"eNamn"`
//     Coadress              interface{} `json:"coAdress"`
//     Fortsadress           interface{} `json:"fortsAdress"`
//     Gatuadress            interface{} `json:"gatuadress"`
//     Postnr                interface{} `json:"postNr"`
//     Postort               interface{} `json:"postOrt"`
//     Kommun                interface{} `json:"kommun"`
//     Telefon               interface{} `json:"telefon"`
//     Relation              bool        `json:"relation"`
//     Ejrelation            bool        `json:"ejRelation"`
//     Harbolagsengagemang   bool        `json:"harBolagsengagemang"`
//     Harejbolagsengagemang bool        `json:"harEjBolagsengagemang"`
//     Man                   bool        `json:"man"`
//     Kvinna                bool        `json:"kvinna"`
//     Alderfran             int         `json:"alderFran"`
//     Aldertill             int         `json:"alderTill"`
//     Fonetisksokning       bool        `json:"fonetiskSokning"`
//     Exaktsokning          bool        `json:"exaktSokning"`
//   } `json:"personFilter"`
//   Foretagfilter struct {
//     Typ                        int         `json:"typ"`
//     Clientqueryid              int         `json:"clientQueryId"`
//     Trafffran                  int         `json:"traffFran"`
//     Vem                        interface{} `json:"vem"`
//     Var                        interface{} `json:"var"`
//     Orgnr                      interface{} `json:"orgNr"`
//     Foretag                    interface{} `json:"foretag"`
//     Gatuadress                 interface{} `json:"gatuadress"`
//     Postnr                     interface{} `json:"postNr"`
//     Postort                    interface{} `json:"postOrt"`
//     Telefon                    interface{} `json:"telefon"`
//     Aktiebolag                 bool        `json:"aktiebolag"`
//     Enskildfirma               bool        `json:"enskildFirma"`
//     Handelsbolagkommanditbolag bool        `json:"handelsbolagKommanditbolag"`
//     Ovriga                     bool        `json:"ovriga"`
//     Fonetisksokning            bool        `json:"fonetiskSokning"`
//     Exaktsokning               bool        `json:"exaktSokning"`
//     Page                       int         `json:"page"`
//   } `json:"foretagFilter"`
//   Visaflik int `json:"visaFlik"`
// }

type RatsitPerson struct {
  RatsitID string
  ToAddress  string
  DisplayName string
  Context string `json:"@context"`
  Type    string `json:"@type"`
  Name    string `json:"name"`
  Address struct {
    Type            string `json:"@type"`
    AddressCountry  string `json:"addressCountry"`
    AddressLocality string `json:"addressLocality"`
    PostalCode      string `json:"postalCode"`
    StreetAddress   string `json:"streetAddress"`
  } `json:"address"`
  BirthDate  string `json:"birthDate"`
  FamilyName string `json:"familyName"`
  Gender     string `json:"gender"`
  GivenName  string `json:"givenName"`
  Telephone  string `json:"telephone"`
  Coordinates string `json:"coordinates"`
}

//type RatsitGeo struct {
//  Context   string `json:"@context"`
//  Type      string `json:"@type"`
//  Latitude  string `json:"latitude"`
//  Longitude string `json:"longitude"`
//}

type HittaPerson struct {
  HittaID       string        `json:"@foobar"`
  Context       string        `json:"@context"`
  Type          string        `json:"@type"`
  Name          string        `json:"name"`
  GivenName     string        `json:"givenName"`
  FamilyName    string        `json:"familyName"`
  Gender        string        `json:"gender"`
  BirthDate     string        `json:"birthDate"`
  AlternateName string        `json:"alternateName"`
  Nationality   string        `json:"nationality"`
  WorkFor       []interface{} `json:"workFor"`
  Address       struct {
    Type            string `json:"@type"`
    StreetAddress   string `json:"streetAddress"`
    AddressLocality string `json:"addressLocality"`
    AddressRegion   string `json:"addressRegion"`
    PostalCode      int    `json:"postalCode"`
    AddressCountry  struct {
      Type string `json:"@type"`
      Name string `json:"name"`
    } `json:"addressCountry"`
  } `json:"address"`
  Geo struct {
    Type      string  `json:"@type"`
    Latitude  float64 `json:"latitude"`
    Longitude float64 `json:"longitude"`
  } `json:"geo"`
}

const hittaurlroot = "https://www.hitta.se/person/"
const ratsiturlroot = "https://www.ratsit.se"

var useTor bool

// Check SQLite error
func checkErr(err error) {
  if err != nil {
    panic(err)
  }
}

type RatsitQuery struct {
	Who            string   `json:"who"`
	Age            []string `json:"age"`
	PhoneticSearch bool     `json:"phoneticSearch"`
	CompanyName    string   `json:"companyName"`
	OrgNr          string   `json:"orgNr"`
	FirstName      string   `json:"firstName"`
	LastName       string   `json:"lastName"`
	PersonNumber   string   `json:"personNumber"`
	Phone          string   `json:"phone"`
	Address        string   `json:"address"`
	Postnr         string   `json:"postnr"`
	Postort        string   `json:"postort"`
	Kommun         string   `json:"kommun"`
	Page           int      `json:"page"`
}

func fromRatsitAPI(theFirst string, theLast string, theSSN string, theCity string) (string) {
  // Example: {"who":"patrik fältström","age":["16","120"],"phoneticSearch":true,"companyName":"","orgNr":"","firstName":"","lastName":"","personNumber":"","phone":"","address":"","postnr":"","postort":"","kommun":"","page":1}

  theURL := "https://www.ratsit.se/api/search/combined"
  q := RatsitQuery{}
  q.PhoneticSearch = false
  q.Age = []string{"16","120"}
  q.Who = theFirst + " " + theLast
  // q.FirstName = theFirst
  // q.LastName = theLast
  q.PersonNumber = theSSN
  q.Postort = theCity
  q.Page = 1
  
  //values := map[string]{"who": "", "age":{16,120}, "phoneticSearch":true, "companyName":"", "orgNr":"", "firstName": theFirst, "lastName": theLast, "personNumber": theSSN, "phone":"", "address":"", "postnr":"", "postort":theCity, "kommun":"","page":1}
  //json_data, err := json.Marshal(values)
  //if err != nil {
  //  log.Fatal(err)
  //}

  //val, err := json.MarshalIndent(q, "", "    ")
  //fmt.Printf("%s\n",val)
  //os.Exit(1)

  spaceClient := http.Client{
    Timeout: time.Second * 10, // Timeout after 2 seconds
  }

  json_data, err := json.Marshal(q)
  req, err := http.NewRequest(http.MethodPost, theURL, bytes.NewBuffer(json_data))
  req.Header.Add("content-type", "application/json; charset=utf-8")

  if(useTor) {
    // Set up a SOCKS5 proxy dialer for Tor
    dialer, err := proxy.SOCKS5("tcp", "localhost:9050", nil, proxy.Direct)
    if err != nil {
      log.Fatal(err)
    }

    // Create a transport that uses the dialer
    transport := &http.Transport{Dial: dialer.Dial}

    spaceClient.Transport = transport
  }

  resp, err := spaceClient.Do(req)
  if err != nil {
    log.Fatal(err)
  }

  //respDump, err := httputil.DumpResponse(resp, true)
  //if err != nil {
  //  log.Fatal(err)
  //}

  //fmt.Printf("RESPONSE:\n%s\n", string(respDump))

  //var res map[string]interface{}
  
  //json.NewDecoder(resp.Body).Decode(&res)

  //fmt.Println(res["json"])

  // Parse the JSON response
  apiResponse := RatsitAutogenerated{}
  json.NewDecoder(resp.Body).Decode(&apiResponse)
  //jsonErr := json.Unmarshal([]byte(body), &apiResponse)
  //jsonErr := json.Unmarshal(, &apiResponse)
  //if jsonErr != nil {
  //  log.Fatal(jsonErr)
  //}
  //val, err := json.MarshalIndent(apiResponse, "", "    ")
  //fmt.Printf("%s\n",val)
  if apiResponse.Person.TotalHits == 0 {
    fmt.Printf("No hits\n")
  }
  if apiResponse.Person.TotalHits > len(apiResponse.Person.Hits) {
    fmt.Printf("Showing first %d records of %d\n", len(apiResponse.Person.Hits), apiResponse.Person.TotalHits)
  } else if len(apiResponse.Person.Hits) > 1 {
    fmt.Printf("Found %d records\n", len(apiResponse.Person.Hits))
  }
  recordNo := -1
  if len(apiResponse.Person.Hits) == 1 {
    recordNo = 0
  } else if len(apiResponse.Person.Hits) > 1 {
    for i, s := range apiResponse.Person.Hits {
      if(s.Hidden) {
        fmt.Printf("%d: Hidden\n", i)
      } else {
        fmt.Printf("%d: %d år, %s %s, %s, %s\n", i, s.Age, s.FirstName, s.LastName, s.StreetAddress, s.City)
      }
    }
    reader := bufio.NewReader(os.Stdin)
    fmt.Print("Choose person: ")
    ans, _ := reader.ReadString('\n')
    recordNo, err = strconv.Atoi(strings.TrimSpace(ans))
    if(err == nil && recordNo >=0 && recordNo < len(apiResponse.Person.Hits)) {
      //fmt.Printf("Selected record %d\n", recordNo)
    } else {
      fmt.Printf("No record selected\n")
      recordNo = -1
    }
  }

  // Check if we got a record selected
  if(recordNo >= 0) {
    theTokens := strings.Split(apiResponse.Person.Hits[recordNo].PersonURL, "/")
    //fmt.Printf("ID: [%s] %s\n", apiResponse.Person.Hits[recordNo].PersonURL, theTokens[4])
    return(theTokens[4])
  } else {
    return("")
  }
}

func fromRatsit(theRatsitID string) (RatsitPerson, error) {
  horoscopeRoot := "https://www.ratsit.se/person/horoskop/"
  theHoroscopeURL := horoscopeRoot + theRatsitID

  spaceClient := http.Client{
    Timeout: time.Second * 10, // Timeout after 10 seconds
  }

  if(useTor) {
    // Set up a SOCKS5 proxy dialer for Tor
    dialer, err := proxy.SOCKS5("tcp", "localhost:9050", nil, proxy.Direct)
    if err != nil {
      log.Fatal(err)
    }

    // Create a transport that uses the dialer
    transport := &http.Transport{Dial: dialer.Dial}

    spaceClient.Transport =  transport
  }

  // fmt.Println("H-URL: ", theHoroscopeURL)
  req, err := http.NewRequest(http.MethodGet, theHoroscopeURL, nil)
  if err != nil {
    log.Fatal(err)
  }

  //req.Header.Set("User-Agent", "paf-adress")
  res, getErr := spaceClient.Do(req)
  if getErr != nil {
    log.Fatal(getErr)
  }

  if res.Body != nil {
    defer res.Body.Close()
  }

  body, readErr := ioutil.ReadAll(res.Body)
  if readErr != nil {
    log.Fatal(readErr)
  }
  //fmt.Println(string(body))
  person := RatsitPerson{}
  // Note: the .*? construction is a non-greedy match, .* is greedy (longest) match
  theRegexp := `"(https://www.ratsit.se/.*?/` + theRatsitID + `)">`
  rgx := regexp.MustCompile(theRegexp)
  rs := rgx.FindStringSubmatch(string(body))
  if len(rs) == 0 {
    return person, errors.New("Did not find person with that id")
  }
  if len(rs) > 0 {
    personURL := rs[1]
    req, err = http.NewRequest(http.MethodGet, personURL, nil)
    if err != nil {
      log.Fatal(err)
    }
    res, getErr = spaceClient.Do(req)
    if getErr != nil {
      log.Fatal(getErr)
    }
    if res.Body != nil {
      defer res.Body.Close()
    }
    body, readErr = ioutil.ReadAll(res.Body)
    if readErr != nil {
      log.Fatal(readErr)
    }

    // Extract the JSON from the webpage
    rgx = regexp.MustCompile(`(?s)application\/ld\+json.*?\[(\{.*\}),(\{.*?\})\]`)
    rs = rgx.FindStringSubmatch(string(body))
    if len(rs) > 0 {
      //fmt.Println("debug:", rs)
      jsonErr := json.Unmarshal([]byte(rs[1]), &person)
      if jsonErr != nil {
        log.Fatal(jsonErr)
      }
      //jsonErr = json.Unmarshal([]byte(rs[2]), &geo)
      //if jsonErr != nil {
      //  log.Fatal(jsonErr)
      //}
    }
  }

  if len(person.Name) > 0 {
    rea := regexp.MustCompile(`^0(.*)$`)
    reb := regexp.MustCompile(`^\+46([0-9].*)$`)
    person.Telephone = rea.ReplaceAllString(person.Telephone, `+46-$1`)
    person.Telephone = reb.ReplaceAllString(person.Telephone, `+46-$1`)
    person.RatsitID = theRatsitID
    person.Coordinates = ""
    return person, nil
  } else {
    return person, errors.New("Did not find person")
  }
}

func fromHitta(theid string) (HittaPerson, error) {
  url := hittaurlroot + theid

  spaceClient := http.Client{
    Timeout: time.Second * 2, // Timeout after 2 seconds
  }

  req, err := http.NewRequest(http.MethodGet, url, nil)
  if err != nil {
    log.Fatal(err)
  }

  //req.Header.Set("User-Agent", "paf-adress")

  res, getErr := spaceClient.Do(req)
  if getErr != nil {
    log.Fatal(getErr)
  }

  if res.Body != nil {
    defer res.Body.Close()
  }

  body, readErr := ioutil.ReadAll(res.Body)
  if readErr != nil {
    log.Fatal(readErr)
  }

  person := HittaPerson{}
  rgx := regexp.MustCompile(`application/ld\+json\"\>([^<]*)\<`)
  rs := rgx.FindStringSubmatch(string(body))
  if len(rs) > 0 {
    jsonErr := json.Unmarshal([]byte(rs[1]), &person)
    if jsonErr != nil {
      log.Fatal(jsonErr)
    }
  }
  if len(person.Name) > 0 {
    return person, nil
  } else {
    return person, errors.New("Did not find person")
  }
}

// Initialize the sqlite3 database
func incsqlite(filename string) (*sql.DB){
  theDB, err := sql.Open("sqlite", filename)
  checkErr(err)
  stmt, err := theDB.Prepare("CREATE TABLE IF NOT EXISTS person (ratsitID TEXT, name TEXT, givenname TEXT, familyname TEXT, telephone TEXT, gender TEXT, birthdate TEXT, streetaddress TEXT, addresslocality TEXT, addresscountry TEXT, postalcode TEXT, latitude TEXT, longitude TEXT, coordinates TEXT, displayname TEXT, toaddress TEXT)")
  checkErr(err)
  _, err = stmt.Exec()
  checkErr(err)
  //stmt, err = theDB.Prepare("CREATE UNIQUE INDEX IF NOT EXISTS ipaddrindex ON ipaddr (prefix, ipaddr, port, protocol)")
  //checkErr(err)
  //_, err = stmt.Exec()
  //checkErr(err)
  return theDB
}

func doAddRatsit(theDB *sql.DB, theID string, p RatsitPerson) {
  _, err := theDB.Exec("INSERT INTO person (ratsitID, name, givenname, familyname, telephone, gender, birthdate, streetaddress, addresslocality, addresscountry, postalcode, coordinates, displayname, toaddress) values (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)", theID, p.Name, p.GivenName, p.FamilyName, p.Telephone, p.Gender, p.BirthDate, p.Address.StreetAddress, p.Address.AddressLocality, p.Address.AddressCountry, p.Address.PostalCode, p.Coordinates, p.DisplayName, p.ToAddress)
  checkErr(err)
}

func doDeleteRatsit(theDB *sql.DB, theID string) {
  _, err := theDB.Exec("DELETE FROM person WHERE ratsitID = ?", theID)
  checkErr(err)
}

func fromDB(theDB *sql.DB, theID string) (RatsitPerson, error) {
  var pa []RatsitPerson
  var p RatsitPerson

  rows,err := theDB.Query("SELECT ratsitID, name, givenname, familyname, telephone, gender, birthdate, streetaddress, addresslocality, addresscountry, postalcode, coordinates, displayname, toaddress FROM person WHERE ratsitID = ?", theID)
  checkErr(err)
  defer rows.Close()
  for rows.Next() {
    if err := rows.Scan(&(p.RatsitID), &(p.Name), &(p.GivenName), &(p.FamilyName), &(p.Telephone), &(p.Gender), &(p.BirthDate), &(p.Address.StreetAddress), &(p.Address.AddressLocality), &(p.Address.AddressCountry), &(p.Address.PostalCode), &(p.Coordinates), &(p.DisplayName), &(p.ToAddress)); err != nil {
      checkErr(err)
    }
    //p.RatsitID = theID
    pa = append(pa, p)
  }
  if len(pa) > 0 {
    return pa[0], nil
  } else {
    return p, errors.New("Did not find person")
  }
}

func searchDB(theDB *sql.DB, theID string, theGivenName string, theFamilyName string, theCity string, theBirthdate string) ([]RatsitPerson, error) {
	var pa []RatsitPerson
	var p RatsitPerson
  theQuery := "SELECT ratsitID, name, givenname, familyname, telephone, gender, birthdate, streetaddress, addresslocality, addresscountry, postalcode, coordinates, displayname, toaddress FROM person WHERE "
  theQuery = theQuery + "ratsitID like '%" + theID + "%'"
  theQuery = theQuery + "and givenname like '%" + theGivenName + "%'"
  theQuery = theQuery + "and familyname like '%" + theFamilyName + "%'"
  theQuery = theQuery + "and addresslocality like '%" + theCity + "%'"
  theQuery = theQuery + "and birthdate like '%" + theBirthdate + "%'"
  theQuery = theQuery + "order by familyname, givenname"
  //fmt.Printf("Looking for %s, %s, %s, %s\n", theGivenName, theFamilyName, theCity, theBirthdate)
  rows,err := theDB.Query(theQuery)
  //	rows,err := theDB.Query("SELECT ratsitID, name, givenname, familyname, telephone, gender, birthdate, streetaddress, addresslocality, addresscountry, postalcode FROM person WHERE givenname like ? and familyname like ? and addresslocality like ? and birthdate like ?", theGivenName, theFamilyName, theCity, theBirthdate)
	checkErr(err)
	defer rows.Close()
	for rows.Next() {
		if err := rows.Scan(&(p.RatsitID), &(p.Name), &(p.GivenName), &(p.FamilyName), &(p.Telephone), &(p.Gender), &(p.BirthDate), &(p.Address.StreetAddress), &(p.Address.AddressLocality), &(p.Address.AddressCountry), &(p.Address.PostalCode), &(p.Coordinates), &(p.DisplayName), &(p.ToAddress)); err != nil {
			checkErr(err)
		}

		pa = append(pa, p)
	}
  if len(pa) > 0 {
    return pa, nil
  } else {
    return pa, errors.New("Did not find any person")
  }
}

func searchBirthdayDB(theDB *sql.DB, days int) ([]RatsitPerson, error) {
  var pa []RatsitPerson
  var p RatsitPerson
  td := time.Now()
  theQuery := "SELECT ratsitID, name, givenname, familyname, telephone, gender, birthdate, streetaddress, addresslocality, addresscountry, postalcode, coordinates, displayname, toaddress FROM person WHERE "
  theQuery = theQuery + "birthdate like '%-" + fmt.Sprintf("%02d-%02d", td.Month(), td.Day()) + "'"
  for i := -1; i < days; i++ {
    td = td.AddDate(0, 0, 1)
    theQuery = theQuery + "or birthdate like '%-" + fmt.Sprintf("%02d-%02d", td.Month(), td.Day()) + "'"
  }
  theQuery = theQuery + " order by substr(birthdate, 6, 5)"
  //fmt.Println(theQuery)
  rows,err := theDB.Query(theQuery)
  checkErr(err)
  defer rows.Close()
  for rows.Next() {
    if err := rows.Scan(&(p.RatsitID), &(p.Name), &(p.GivenName), &(p.FamilyName), &(p.Telephone), &(p.Gender), &(p.BirthDate), &(p.Address.StreetAddress), &(p.Address.AddressLocality), &(p.Address.AddressCountry), &(p.Address.PostalCode), &(p.Coordinates), &(p.DisplayName), &(p.ToAddress)); err != nil {
      checkErr(err)
    }
    pa = append(pa, p)
  }
  if len(pa) > 0 {
    return pa, nil
  } else {
    return pa, errors.New("Did not find any person")
  }
}

func main() {

  // Init database
  dbfilepath := "/Users/paf/Documents/addressbook.sqlite"
  theDB := incsqlite(dbfilepath)

  // Handle arguments
  idPtr := flag.String("id", "", "a unique id for a record")
  //hittaPtr := flag.String("hitta", "", "use Hitta")
  addBool := flag.Bool("add", false, "add record")
  findBool := flag.Bool("find", false, "find records online")
  diffBool := flag.Bool("diff", false, "compare records")
  toorBool := flag.Bool("tor", false, "use local TOR socks proxy")
  useTor = *toorBool
  birthdayNum := flag.Int("birthday", -1, "who has birthday soon")
  ratsitFirstName := flag.String("first", "", "the first name of the person")
  ratsitLastName := flag.String("last", "", "the last name of the person")
  ratsitCity := flag.String("city", "", "the city the person lives in")
  ratsitSSN := flag.String("ssn", "", "the swedish social security number (YYYYMMDDNNNN)")
  flag.Parse()

  // If we are looking for future birthdays
  if(*birthdayNum >= 0) {
    ratsitpersons, _ := searchBirthdayDB(theDB, *birthdayNum)
    if(len(ratsitpersons) > 0) {
      for _, s := range ratsitpersons {
        fmt.Printf("%s, %s, %s, %s %s, %s\n",s.BirthDate, s.Name, s.Address.StreetAddress, s.Address.PostalCode, s.Address.AddressLocality, s.Telephone);
      }
    }
    return
  }

  // If we have not asked for lookup of records online
  if(!(*findBool) && !(*diffBool)) {
    ratsitpersons, _ := searchDB(theDB, *idPtr, *ratsitFirstName, *ratsitLastName, *ratsitCity, *ratsitSSN)
    //fmt.Printf("%d found\n", len(ratsitpersons))
    if(len(ratsitpersons) > 0) {
      for _, s := range ratsitpersons {
        fmt.Printf("%s, %s, %s, %s %s, %s %s\n",s.BirthDate, s.Name, s.Address.StreetAddress, s.Address.PostalCode, s.Address.AddressLocality, s.Telephone, s.Coordinates);
      }
    }
    return
  }

  // If we have asked for a diff to be made
  if(*diffBool) {
    ratsitpersons, _ := searchDB(theDB, *idPtr, *ratsitFirstName, *ratsitLastName, *ratsitCity, *ratsitSSN)
    //fmt.Printf("%d found\n", len(ratsitpersons))
    if(len(ratsitpersons) > 0) {
      for _, s := range ratsitpersons {
        if(s.RatsitID == "") {
          fmt.Printf("Will not check %s in Ratsit\n",s.Name)
          continue
        }
        // Do not dos the service, pause 1s between each call
        time.Sleep(1 * time.Second)
        fmt.Printf("Checking %s...", s.Name)
        t, err := fromRatsit(s.RatsitID)
        if(err != nil) {
          fmt.Printf("MISSING!\nMISSING: %s, %s, %s, %s %s, %s\n",s.BirthDate, s.Name, s.Address.StreetAddress, s.Address.PostalCode, s.Address.AddressLocality, s.Telephone);
          fmt.Printf("===========================\n")
        } else {
          if(s.Name == t.Name &&
            s.Address.StreetAddress == t.Address.StreetAddress &&
            s.Address.PostalCode == t.Address.PostalCode &&
            s.Address.AddressLocality == t.Address.AddressLocality &&
            s.Telephone == t.Telephone) {
            fmt.Printf("ok\n")
          } else {
            fmt.Printf("\nOLD: %s, %s, %s, %s %s, %s\n",s.BirthDate, s.Name, s.Address.StreetAddress, s.Address.PostalCode, s.Address.AddressLocality, s.Telephone);
            fmt.Printf("NEW: %s, %s, %s, %s %s, %s\n",t.BirthDate, t.Name, t.Address.StreetAddress, t.Address.PostalCode, t.Address.AddressLocality, t.Telephone);
            // If we have asked for the record to be updated, delete and add again
            if(*addBool) {
              t.Coordinates = s.Coordinates
              doDeleteRatsit(theDB, s.RatsitID)
              doAddRatsit(theDB, s.RatsitID, t)
              fmt.Printf("UPDATED\n")
            }
            fmt.Printf("===========================\n")
          }
        }
      }
    }
    return
  }

  // If we are looking for records in Ratsit
  var getRatsitPerson RatsitPerson
  var fetcherr error

  ratsitID := *idPtr
  // If we do not have any RatsitID yet, do a search
  if(len(ratsitID) == 0) {
    ratsitID = fromRatsitAPI(*ratsitFirstName, *ratsitLastName, *ratsitSSN, *ratsitCity)
  }

  if len(ratsitID) > 0 {
    getRatsitPerson, fetcherr = fromRatsit(ratsitID)
  }
  if fetcherr != nil {
    log.Fatal("Did not find person with ID ",ratsitID)
  }
  if(len(ratsitID) > 0) {
    fmt.Printf("ID: %s\n", getRatsitPerson.RatsitID)
    fmt.Printf("Name: %s\n", getRatsitPerson.Name)
    fmt.Printf("Address: %s\n", getRatsitPerson.Address.StreetAddress)
    fmt.Printf("Postal address: %s %s\n", getRatsitPerson.Address.PostalCode, getRatsitPerson.Address.AddressLocality)
    fmt.Printf("Birth date: %s\n", getRatsitPerson.BirthDate)
    fmt.Printf("Telephone: %s\n", getRatsitPerson.Telephone)
    // If we asked for the person to be added, add it
    if(*addBool) {
      // Check if person already exists with this id
      _, err := fromDB(theDB, ratsitID)
      if(err == nil) {
        fmt.Printf("Person already exists with id %s\n", ratsitID)
      } else {
        doAddRatsit(theDB, ratsitID, getRatsitPerson)
        fmt.Printf("Added person\n")
        fmt.Printf("Recommended next command with arguments -sheets -fix\n")
      }
    }
  }
}
