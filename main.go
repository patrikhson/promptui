package main

import (
  "os"
  "bufio"
	"errors"
	"regexp"
	"encoding/json"
	"fmt"
	"io/ioutil"
	"log"
  "strings"
  "strconv"
	"net/http"
  "net/url"
	"time"
	"flag"
	
	// SQLite3 package
	"database/sql"
	//_ "github.com/mattn/go-sqlite3"
  _ "modernc.org/sqlite"
)

// ratsit api https://www.ratsit.se/api/search/person?fnamn=patrik&enamn=f%C3%A4ltstr%C3%B6m&gata=&postnr=&ort=&kn=&pnr=196505&tfn=&m=1&k=1&r=1&er=1&b=1&eb=1&amin=16&amax=120&fon=1&typ=2&page=1
type RatsitAutogenerated struct {
	Snabbsok  bool        `json:"snabbSok"`
	Text      interface{} `json:"text"`
	Vemvarsok bool        `json:"vemVarSok"`
	Vem       interface{} `json:"vem"`
	Var       interface{} `json:"var"`
	Person    struct {
		Nysokning             bool `json:"nySokning"`
		Visaantaltraffar      bool `json:"visaAntalTraffar"`
		Flertraffar           bool `json:"flerTraffar"`
		Antaltraffartotalt    int  `json:"antalTraffarTotalt"`
		Antaltraffarbegransat bool `json:"antalTraffarBegransat"`
		Nastatrafffran        int  `json:"nastaTraffFran"`
		Antaldoldatraffar     int  `json:"antalDoldaTraffar"`
		Isuservalidated       bool `json:"isUserValidated"`
		Isuserpluscustomer    bool `json:"isUserPlusCustomer"`
		List                  []struct {
			Ishiddenperson        bool     `json:"isHiddenPerson"`
			Lastnamecomplete      string   `json:"lastNameComplete"`
			Hashiddenaddress      bool     `json:"hasHiddenAddress"`
			Address               string   `json:"address"`
			Postnr                string   `json:"postNr"`
			Postort               string   `json:"postort"`
			Isfemale              bool     `json:"isFemale"`
			Hasrelation           bool     `json:"hasRelation"`
			Age                   int      `json:"age"`
			Personrapporturl      string   `json:"personrapportUrl"`
			Givennames            []string `json:"givenNames"`
			Names                 []string `json:"names"`
			Hasbolagsengagemang   bool     `json:"hasBolagsengagemang"`
			Antalbolagsengagemang int      `json:"antalBolagsengagemang"`
		} `json:"list"`
		Paging struct {
			Totalpages               int         `json:"totalPages"`
			Allowedpages             int         `json:"allowedPages"`
			Visiblepageslowindex     int         `json:"visiblePagesLowIndex"`
			Visiblepageshighindex    int         `json:"visiblePagesHighIndex"`
			Pageindex                int         `json:"pageIndex"`
			Hasnextpage              bool        `json:"hasNextPage"`
			Haspreviouspage          bool        `json:"hasPreviousPage"`
			Hasnextpageurl           interface{} `json:"hasNextPageUrl"`
			Haspreviouspageurl       interface{} `json:"hasPreviousPageUrl"`
			Showfirstshortcut        bool        `json:"showFirstShortcut"`
			Showlastshortcut         bool        `json:"showLastShortcut"`
			Showfirstshortcutelipsis bool        `json:"showFirstShortcutElipsis"`
			Showlastshortcutelipsis  bool        `json:"showLastShortcutElipsis"`
			Showloginformoremessage  bool        `json:"showLoginForMoreMessage"`
		} `json:"paging"`
	} `json:"person"`
	Company struct {
		Clientqueryid         int           `json:"clientQueryId"`
		Nysokning             bool          `json:"nySokning"`
		Visaantaltraffar      bool          `json:"visaAntalTraffar"`
		Flertraffar           bool          `json:"flerTraffar"`
		Antaltraffartotalt    int           `json:"antalTraffarTotalt"`
		Antaltraffarbegransat bool          `json:"antalTraffarBegransat"`
		Nastatrafffran        int           `json:"nastaTraffFran"`
		List                  []interface{} `json:"list"`
		Paging                struct {
			Totalpages               int         `json:"totalPages"`
			Allowedpages             int         `json:"allowedPages"`
			Visiblepageslowindex     int         `json:"visiblePagesLowIndex"`
			Visiblepageshighindex    int         `json:"visiblePagesHighIndex"`
			Pageindex                int         `json:"pageIndex"`
			Hasnextpage              bool        `json:"hasNextPage"`
			Haspreviouspage          bool        `json:"hasPreviousPage"`
			Hasnextpageurl           interface{} `json:"hasNextPageUrl"`
			Haspreviouspageurl       interface{} `json:"hasPreviousPageUrl"`
			Showfirstshortcut        bool        `json:"showFirstShortcut"`
			Showlastshortcut         bool        `json:"showLastShortcut"`
			Showfirstshortcutelipsis bool        `json:"showFirstShortcutElipsis"`
			Showlastshortcutelipsis  bool        `json:"showLastShortcutElipsis"`
			Showloginformoremessage  bool        `json:"showLoginForMoreMessage"`
		} `json:"paging"`
	} `json:"company"`
	Personfilter struct {
		Page                  int         `json:"page"`
		Typ                   int         `json:"typ"`
		Clientqueryid         int         `json:"clientQueryId"`
		Trafffran             int         `json:"traffFran"`
		Vem                   interface{} `json:"vem"`
		Var                   interface{} `json:"var"`
		Pnr                   string      `json:"pNr"`
		Fnamn                 interface{} `json:"fNamn"`
		Tnamn                 interface{} `json:"tNamn"`
		Enamn                 interface{} `json:"eNamn"`
		Coadress              interface{} `json:"coAdress"`
		Fortsadress           interface{} `json:"fortsAdress"`
		Gatuadress            interface{} `json:"gatuadress"`
		Postnr                interface{} `json:"postNr"`
		Postort               interface{} `json:"postOrt"`
		Kommun                interface{} `json:"kommun"`
		Telefon               interface{} `json:"telefon"`
		Relation              bool        `json:"relation"`
		Ejrelation            bool        `json:"ejRelation"`
		Harbolagsengagemang   bool        `json:"harBolagsengagemang"`
		Harejbolagsengagemang bool        `json:"harEjBolagsengagemang"`
		Man                   bool        `json:"man"`
		Kvinna                bool        `json:"kvinna"`
		Alderfran             int         `json:"alderFran"`
		Aldertill             int         `json:"alderTill"`
		Fonetisksokning       bool        `json:"fonetiskSokning"`
		Exaktsokning          bool        `json:"exaktSokning"`
	} `json:"personFilter"`
	Foretagfilter struct {
		Typ                        int         `json:"typ"`
		Clientqueryid              int         `json:"clientQueryId"`
		Trafffran                  int         `json:"traffFran"`
		Vem                        interface{} `json:"vem"`
		Var                        interface{} `json:"var"`
		Orgnr                      interface{} `json:"orgNr"`
		Foretag                    interface{} `json:"foretag"`
		Gatuadress                 interface{} `json:"gatuadress"`
		Postnr                     interface{} `json:"postNr"`
		Postort                    interface{} `json:"postOrt"`
		Telefon                    interface{} `json:"telefon"`
		Aktiebolag                 bool        `json:"aktiebolag"`
		Enskildfirma               bool        `json:"enskildFirma"`
		Handelsbolagkommanditbolag bool        `json:"handelsbolagKommanditbolag"`
		Ovriga                     bool        `json:"ovriga"`
		Fonetisksokning            bool        `json:"fonetiskSokning"`
		Exaktsokning               bool        `json:"exaktSokning"`
		Page                       int         `json:"page"`
	} `json:"foretagFilter"`
	Visaflik int `json:"visaFlik"`
}

type RatsitPerson struct {
  RatsitID string
	Context string `json:"@context"`
	Type    string `json:"@type"`
	Name    string `json:"name"`
	Address struct {
		Type            string `json:"@type"`
		AddressCountry  string `json:"addressCountry"`
		AddressLocality string `json:"addressLocality"`
		PostalCode      string `json:"postalCode"`
		StreetAddress   string `json:"streetAddress"`
	} `json:"address"`
	BirthDate  string `json:"birthDate"`
	FamilyName string `json:"familyName"`
	Gender     string `json:"gender"`
	GivenName  string `json:"givenName"`
  Telephone  string `json:"telephone"`
}

//type RatsitGeo struct {
//	Context   string `json:"@context"`
//	Type      string `json:"@type"`
//	Latitude  string `json:"latitude"`
//	Longitude string `json:"longitude"`
//}

type HittaPerson struct {
	HittaID       string        `json:"@foobar"`
	Context       string        `json:"@context"`
	Type          string        `json:"@type"`
	Name          string        `json:"name"`
	GivenName     string        `json:"givenName"`
	FamilyName    string        `json:"familyName"`
	Gender        string        `json:"gender"`
	BirthDate     string        `json:"birthDate"`
	AlternateName string        `json:"alternateName"`
	Nationality   string        `json:"nationality"`
	WorkFor       []interface{} `json:"workFor"`
	Address       struct {
		Type            string `json:"@type"`
		StreetAddress   string `json:"streetAddress"`
		AddressLocality string `json:"addressLocality"`
		AddressRegion   string `json:"addressRegion"`
		PostalCode      int    `json:"postalCode"`
		AddressCountry  struct {
			Type string `json:"@type"`
			Name string `json:"name"`
		} `json:"addressCountry"`
	} `json:"address"`
	Geo struct {
		Type      string  `json:"@type"`
		Latitude  float64 `json:"latitude"`
		Longitude float64 `json:"longitude"`
	} `json:"geo"`
}

const hittaurlroot = "https://www.hitta.se/person/"
const ratsiturlroot = "https://www.ratsit.se"

// Check SQLite error
func checkErr(err error) {
    if err != nil {
		panic(err)
    }
}

func fromRatsitAPI(theFirst string, theLast string, theSSN string, theCity string) (string) {
  theURL := "https://www.ratsit.se/api/search/person?"
  theURL = theURL + "fnamn=" + url.QueryEscape(theFirst) + "&enamn=" + url.QueryEscape(theLast) + "&gata=&postnr=&ort=" + url.QueryEscape(theCity) + "&kn=&pnr=" + theSSN + "&tfn=&m=1&k=1&r=1&er=1&b=1&eb=1&amin=16&amax=120&fon=1&typ=2&page=1"
  
	spaceClient := http.Client{
		Timeout: time.Second * 10, // Timeout after 2 seconds
	}

	req, err := http.NewRequest(http.MethodGet, theURL, nil)
	if err != nil {
		log.Fatal(err)
	}

	req.Header.Set("Accept", "application/json")
	res, getErr := spaceClient.Do(req)
	if getErr != nil {
		log.Fatal(getErr)
	}

	if res.Body != nil {
		defer res.Body.Close()
	}

	body, readErr := ioutil.ReadAll(res.Body)
	if readErr != nil {
		log.Fatal(readErr)
	}

  // Parse the JSON response
  apiResponse := RatsitAutogenerated{}
  jsonErr := json.Unmarshal([]byte(body), &apiResponse)
  if jsonErr != nil {
    log.Fatal(jsonErr)
  }
  if apiResponse.Person.Antaltraffartotalt == 0 {
    fmt.Printf("No hits\n")
  }
  if apiResponse.Person.Antaltraffartotalt > len(apiResponse.Person.List) {
    fmt.Printf("Showing first %d records of %d\n", len(apiResponse.Person.List), apiResponse.Person.Antaltraffartotalt)
  } else if len(apiResponse.Person.List) > 1 {
    fmt.Printf("Found %d records\n", len(apiResponse.Person.List))
  }
  recordNo := -1
  if len(apiResponse.Person.List) == 1 {
    recordNo = 0
  } else if len(apiResponse.Person.List) > 1 {
    for i, s := range apiResponse.Person.List {
      if(s.Ishiddenperson) {
        fmt.Printf("%d: Hidden\n", i)
      } else {
        fmt.Printf("%d: %s %s %s, %s, %s %s\n", i, s.Personrapporturl[1:9], strings.Join(s.Names[:]," "), s.Lastnamecomplete, s.Address, s.Postnr, s.Postort)
      }
    }
    reader := bufio.NewReader(os.Stdin)
    fmt.Print("Choose person: ")
    ans, _ := reader.ReadString('\n')
    recordNo, err = strconv.Atoi(strings.TrimSpace(ans))
    if(err == nil && recordNo >=0 && recordNo < len(apiResponse.Person.List)) {
      //fmt.Printf("Selected record %d\n", recordNo)
    } else {
      fmt.Printf("No record selected\n")
      recordNo = -1
    }
  }

  // Check if we got a record selected
  if(recordNo >= 0) {
    theTokens := strings.Split(apiResponse.Person.List[recordNo].Personrapporturl, "/")
    //fmt.Printf("ID: %s\n", theTokens[2])
    return(theTokens[2])
  } else {
    return("")
  }
}

func fromRatsit(theRatsitID string) (RatsitPerson, error) {
  horoscopeRoot := "https://www.ratsit.se/person/horoskop/"
  theHoroscopeURL := horoscopeRoot + theRatsitID
  
	spaceClient := http.Client{
		Timeout: time.Second * 10, // Timeout after 10 seconds
	}

	req, err := http.NewRequest(http.MethodGet, theHoroscopeURL, nil)
	if err != nil {
		log.Fatal(err)
	}

	//req.Header.Set("User-Agent", "paf-adress")
	res, getErr := spaceClient.Do(req)
	if getErr != nil {
		log.Fatal(getErr)
	}

	if res.Body != nil {
		defer res.Body.Close()
	}

	body, readErr := ioutil.ReadAll(res.Body)
	if readErr != nil {
		log.Fatal(readErr)
	}

	person := RatsitPerson{}
  // Note: the .*? construction is a non-greedy match, .* is greedy (longest) match
	rgx := regexp.MustCompile(`<a class="section-topbar-link" href="(.*?)"`)
  rs := rgx.FindStringSubmatch(string(body))
  if len(rs) > 0 {
    personURL := rs[1]
    req, err = http.NewRequest(http.MethodGet, personURL, nil)
    if err != nil {
      log.Fatal(err)
    }
		res, getErr = spaceClient.Do(req)
		if getErr != nil {
			log.Fatal(getErr)
		}
		if res.Body != nil {
			defer res.Body.Close()
		}
		body, readErr = ioutil.ReadAll(res.Body)
		if readErr != nil {
			log.Fatal(readErr)
		}

    // Extract the JSON from the webpage
    rgx = regexp.MustCompile(`(?s)application\/ld\+json.*?\[(\{.*\}),(\{.*?\})\]`)
		rs = rgx.FindStringSubmatch(string(body))
		if len(rs) > 0 {
      //fmt.Println("debug:", rs)
      jsonErr := json.Unmarshal([]byte(rs[1]), &person)
			if jsonErr != nil {
				log.Fatal(jsonErr)
			}
			//jsonErr = json.Unmarshal([]byte(rs[2]), &geo)
			//if jsonErr != nil {
			//	log.Fatal(jsonErr)
      //}
		}
  }

	if len(person.Name) > 0 {
    person.RatsitID = theRatsitID
		return person, nil
	} else {
		return person, errors.New("Did not find person")
	}
}

func fromHitta(theid string) (HittaPerson, error) {
	url := hittaurlroot + theid

	spaceClient := http.Client{
		Timeout: time.Second * 2, // Timeout after 2 seconds
	}

	req, err := http.NewRequest(http.MethodGet, url, nil)
	if err != nil {
		log.Fatal(err)
	}

	//req.Header.Set("User-Agent", "paf-adress")

	res, getErr := spaceClient.Do(req)
	if getErr != nil {
		log.Fatal(getErr)
	}

	if res.Body != nil {
		defer res.Body.Close()
	}

	body, readErr := ioutil.ReadAll(res.Body)
	if readErr != nil {
		log.Fatal(readErr)
	}

	person := HittaPerson{}
	rgx := regexp.MustCompile(`application/ld\+json\"\>([^<]*)\<`)
	rs := rgx.FindStringSubmatch(string(body))
	if len(rs) > 0 {
		jsonErr := json.Unmarshal([]byte(rs[1]), &person)
		if jsonErr != nil {
			log.Fatal(jsonErr)
		}
	}
	if len(person.Name) > 0 {
		return person, nil
	} else {
		return person, errors.New("Did not find person")
	}
}

// Initialize the sqlite3 database
func incsqlite(filename string) (*sql.DB){
    theDB, err := sql.Open("sqlite", filename)
    checkErr(err)
	stmt, err := theDB.Prepare("CREATE TABLE IF NOT EXISTS person (ratsitID TEXT, name TEXT, givenname TEXT, familyname TEXT, telephone TEXT, gender TEXT, birthdate TEXT, streetaddress TEXT, addresslocality TEXT, addresscountry TEXT, postalcode TEXT, latitude TEXT, longitude TEXT)")
	checkErr(err)
	_, err = stmt.Exec()
	checkErr(err)
	//stmt, err = theDB.Prepare("CREATE UNIQUE INDEX IF NOT EXISTS ipaddrindex ON ipaddr (prefix, ipaddr, port, protocol)")
    //checkErr(err)
	//_, err = stmt.Exec()
	//checkErr(err)
	return theDB
}

func doAddRatsit(theDB *sql.DB, theID string, p RatsitPerson) {
	_, err := theDB.Exec("INSERT INTO person (ratsitID, name, givenname, familyname, telephone, gender, birthdate, streetaddress, addresslocality, addresscountry, postalcode) values (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)", theID, p.Name, p.GivenName, p.FamilyName, p.Telephone, p.Gender, p.BirthDate, p.Address.StreetAddress, p.Address.AddressLocality, p.Address.AddressCountry, p.Address.PostalCode)
	checkErr(err)
}

func doDeleteRatsit(theDB *sql.DB, theID string) {
	_, err := theDB.Exec("DELETE FROM person WHERE ratsitID = ?", theID)
	checkErr(err)
}

func fromDB(theDB *sql.DB, theID string) (RatsitPerson, error) {
	var pa []RatsitPerson
	var p RatsitPerson

	rows,err := theDB.Query("SELECT ratsitID, name, givenname, familyname, telephone, gender, birthdate, streetaddress, addresslocality, addresscountry, postalcode FROM person WHERE ratsitID = ?", theID)
	checkErr(err)
	defer rows.Close()
	for rows.Next() {
		if err := rows.Scan(&(p.RatsitID), &(p.Name), &(p.GivenName), &(p.FamilyName), &(p.Telephone), &(p.Gender), &(p.BirthDate), &(p.Address.StreetAddress), &(p.Address.AddressLocality), &(p.Address.AddressCountry), &(p.Address.PostalCode)); err != nil {
			checkErr(err)
		}
		//p.RatsitID = theID
		pa = append(pa, p)
	}
  if len(pa) > 0 {
    return pa[0], nil
  } else {
    return p, errors.New("Did not find person")
  }
}

func searchDB(theDB *sql.DB, theGivenName string, theFamilyName string, theCity string, theBirthdate string) ([]RatsitPerson, error) {
	var pa []RatsitPerson
	var p RatsitPerson
  theQuery := "SELECT ratsitID, name, givenname, familyname, telephone, gender, birthdate, streetaddress, addresslocality, addresscountry, postalcode FROM person WHERE "
  theQuery = theQuery + "givenname like '%" + theGivenName + "%'"
  theQuery = theQuery + "and familyname like '%" + theFamilyName + "%'"
  theQuery = theQuery + "and addresslocality like '%" + theCity + "%'"
  theQuery = theQuery + "and birthdate like '%" + theBirthdate + "%'"
  theQuery = theQuery + "order by familyname, givenname"
  //fmt.Printf("Looking for %s, %s, %s, %s\n", theGivenName, theFamilyName, theCity, theBirthdate)
  rows,err := theDB.Query(theQuery)
  //	rows,err := theDB.Query("SELECT ratsitID, name, givenname, familyname, telephone, gender, birthdate, streetaddress, addresslocality, addresscountry, postalcode FROM person WHERE givenname like ? and familyname like ? and addresslocality like ? and birthdate like ?", theGivenName, theFamilyName, theCity, theBirthdate)
	checkErr(err)
	defer rows.Close()
	for rows.Next() {
		if err := rows.Scan(&(p.RatsitID), &(p.Name), &(p.GivenName), &(p.FamilyName), &(p.Telephone), &(p.Gender), &(p.BirthDate), &(p.Address.StreetAddress), &(p.Address.AddressLocality), &(p.Address.AddressCountry), &(p.Address.PostalCode)); err != nil {
			checkErr(err)
		}
		pa = append(pa, p)
	}
  if len(pa) > 0 {
    return pa, nil
  } else {
    return pa, errors.New("Did not find any person")
  }
}

func main() {

	// Init database
	dbfilepath := "/Users/paf/Documents/addressbook.sqlite"
	theDB := incsqlite(dbfilepath)

	// Handle arguments
	idPtr := flag.String("id", "", "a unique id for a record in ratsit")
	dbidPtr := flag.String("dbid", "", "a unique id for a record in database")
	//hittaPtr := flag.String("hitta", "", "use Hitta")
	addBool := flag.Bool("add", false, "add record")
	listBool := flag.Bool("list", false, "list records")
	diffBool := flag.Bool("diff", false, "compare records")
  ratsitFirstName := flag.String("first", "", "the first name of the person")
  ratsitLastName := flag.String("last", "", "the last name of the person")
  ratsitCity := flag.String("city", "", "the city the person lives in")
  ratsitSSN := flag.String("ssn", "", "the swedish social security number (YYYYMMDDNNNN)")
	flag.Parse()

  if(*listBool) {
    ratsitpersons, _ := searchDB(theDB, *ratsitFirstName, *ratsitLastName, *ratsitCity, *ratsitSSN)
    //fmt.Printf("%d found\n", len(ratsitpersons))
    if(len(ratsitpersons) > 0) {
      for _, s := range ratsitpersons {
        fmt.Printf("%s, %s, %s, %s %s, %s\n",s.BirthDate, s.Name, s.Address.StreetAddress, s.Address.PostalCode, s.Address.AddressLocality, s.Telephone);
      }
    }
    return
  }

  if(*diffBool) {
    ratsitpersons, _ := searchDB(theDB, *ratsitFirstName, *ratsitLastName, *ratsitCity, *ratsitSSN)
    //fmt.Printf("%d found\n", len(ratsitpersons))
    if(len(ratsitpersons) > 0) {
      for _, s := range ratsitpersons {
        time.Sleep(1 * time.Second)
        fmt.Printf("Checking %s...", s.Name)
        t, err := fromRatsit(s.RatsitID)
        if(err != nil) {
          fmt.Printf("MISSING: %s, %s, %s, %s %s, %s\n",s.BirthDate, s.Name, s.Address.StreetAddress, s.Address.PostalCode, s.Address.AddressLocality, s.Telephone);
          fmt.Printf("===========================\n")
        } else {
          if(s.Name == t.Name &&
            s.Address.StreetAddress == t.Address.StreetAddress &&
            s.Address.PostalCode == t.Address.PostalCode &&
            s.Address.AddressLocality == t.Address.AddressLocality &&
            s.Telephone == t.Telephone) {
            fmt.Printf("ok\n")
          } else {
            fmt.Printf("OLD: %s, %s, %s, %s %s, %s\n",s.BirthDate, s.Name, s.Address.StreetAddress, s.Address.PostalCode, s.Address.AddressLocality, s.Telephone);
            fmt.Printf("NEW: %s, %s, %s, %s %s, %s\n",t.BirthDate, t.Name, t.Address.StreetAddress, t.Address.PostalCode, t.Address.AddressLocality, t.Telephone);
            if(*addBool) {
              doDeleteRatsit(theDB, s.RatsitID)
              doAddRatsit(theDB, s.RatsitID, s)
              fmt.Printf("UPDATED\n")
            }
            fmt.Printf("===========================\n")
          }
        }
      }
    }
    return
  }

  
  ratsitID := *idPtr
  dbID := *dbidPtr
  if(len(dbID) > 0) {
    ratsitID = dbID
  }
  if(len(ratsitID) == 0) {
    ratsitID = fromRatsitAPI(*ratsitFirstName, *ratsitLastName, *ratsitSSN, *ratsitCity)
  }

  var getRatsitPerson RatsitPerson
  var fetcherr error
  // Note that ratsitID == dbID iff dbID is set
  if len(dbID) > 0 {
    getRatsitPerson, fetcherr = fromDB(theDB, ratsitID)
  } else if len(ratsitID) > 0 {
    getRatsitPerson, fetcherr = fromRatsit(ratsitID)
  }
  if fetcherr != nil {
    log.Fatal("Did not find person with ID ",ratsitID)
  }
  if(len(ratsitID) > 0) {
    fmt.Printf("ID: %s\n", getRatsitPerson.RatsitID)
    fmt.Printf("Name: %s\n", getRatsitPerson.Name)
    fmt.Printf("Address: %s\n", getRatsitPerson.Address.StreetAddress)
    fmt.Printf("Postal address: %s %s\n", getRatsitPerson.Address.PostalCode, getRatsitPerson.Address.AddressLocality)
    fmt.Printf("Birth date: %s\n", getRatsitPerson.BirthDate)
    fmt.Printf("Telephone: %s\n", getRatsitPerson.Telephone)
    if(*addBool) {
      // Check if person already exists with this id
      _, err := fromDB(theDB, ratsitID)
      if(err == nil) {
        fmt.Printf("Person already exists with id %s\n", ratsitID)
      } else {
        doAddRatsit(theDB, ratsitID, getRatsitPerson)
        fmt.Printf("Added person\n")
      }
    }
  }
}
