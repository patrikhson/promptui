package main

import (
  "os"
  "bytes"
  "bufio"
  "errors"
  "regexp"
  "encoding/json"
  "fmt"
  "io/ioutil"
  "log"
  "strings"
  "strconv"
  "net/http"
  //"net/http/httputil"
  //"net/url"
  "time"
  "flag"

  // SOCKS proxy (for TOR)
  "golang.org/x/net/proxy"
  
  // Google Sheets
  "gopkg.in/Iwark/spreadsheet.v2"
  "golang.org/x/net/context"
  "golang.org/x/oauth2/google"

  // SQLite3 package
  "database/sql"
  //_ "github.com/mattn/go-sqlite3"
  _ "modernc.org/sqlite"
)

// ratsit api https://www.ratsit.se/api/search/person?fnamn=patrik&enamn=f%C3%A4ltstr%C3%B6m&gata=&postnr=&ort=&kn=&pnr=196505&tfn=&m=1&k=1&r=1&er=1&b=1&eb=1&amin=16&amax=120&fon=1&typ=2&page=1

type RatsitAutogenerated struct {
	Company struct {
		Hits []struct {
			CompanyName    string `json:"companyName"`
			Address        string `json:"address"`
			BolagsformCode int    `json:"bolagsformCode"`
			ID             string `json:"id"`
			Coordinates    struct {
				Lat string `json:"lat"`
				Lng string `json:"lng"`
			} `json:"coordinates"`
			CompanyURL string `json:"companyUrl"`
		} `json:"hits"`
		FilterOptions struct {
			BolagsformCode []struct {
				Input    string `json:"input"`
				Text     string `json:"text"`
				Key      string `json:"key"`
				Count    int    `json:"count"`
				Selected bool   `json:"selected"`
			} `json:"bolagsformCode"`
		} `json:"filterOptions"`
		Pager struct {
			PageIndex                     int   `json:"pageIndex"`
			PageCount                     int   `json:"pageCount"`
			VisiblePages                  []int `json:"visiblePages"`
			ShowBack                      bool  `json:"showBack"`
			ShowForward                   bool  `json:"showForward"`
			ShowFirstPageShortcut         bool  `json:"showFirstPageShortcut"`
			ShowFirstPageShortcutEllipsis bool  `json:"showFirstPageShortcutEllipsis"`
			ShowLastPageShortcut          bool  `json:"showLastPageShortcut"`
			ShowLastPageShortcutEllipsis  bool  `json:"showLastPageShortcutEllipsis"`
			AreMorePagesAvailable         bool  `json:"areMorePagesAvailable"`
		} `json:"pager"`
		TotalHits int `json:"totalHits"`
	} `json:"company"`
	Person struct {
		Hits []struct {
			Hidden                  bool   `json:"hidden"`
			ID                      string `json:"id"`
			FirstName               string `json:"firstName"`
			LastName                string `json:"lastName"`
			GivenName               string `json:"givenName"`
			Age                     int    `json:"age"`
			StreetAddress           string `json:"streetAddress"`
			City                    string `json:"city"`
			Married                 bool   `json:"married"`
			Gender                  string `json:"gender"`
			HasCorporateEngagements bool   `json:"hasCorporateEngagements"`
			Coordinates             struct {
				Lat string `json:"lat"`
				Lng string `json:"lng"`
			} `json:"coordinates"`
			PersonURL     string `json:"personUrl"`
			LoneKollenURL string `json:"loneKollenUrl"`
		} `json:"hits"`
		FilterOptions struct {
			Gender []struct {
				Input    string `json:"input"`
				Text     string `json:"text"`
				Key      string `json:"key"`
				Count    int    `json:"count"`
				Selected bool   `json:"selected"`
			} `json:"gender"`
			CorporateEngagements []struct {
				Input    string `json:"input"`
				Text     string `json:"text"`
				Key      string `json:"key"`
				Count    int    `json:"count"`
				Selected bool   `json:"selected"`
			} `json:"corporateEngagements"`
			MaritalStatus []struct {
				Input    string `json:"input"`
				Text     string `json:"text"`
				Key      string `json:"key"`
				Count    int    `json:"count"`
				Selected bool   `json:"selected"`
			} `json:"maritalStatus"`
			Age []struct {
				Input    string `json:"input"`
				Text     string `json:"text"`
				Key      string `json:"key"`
				Count    int    `json:"count"`
				Selected bool   `json:"selected"`
			} `json:"age"`
		} `json:"filterOptions"`
		Pager struct {
			PageIndex                     int   `json:"pageIndex"`
			PageCount                     int   `json:"pageCount"`
			VisiblePages                  []int `json:"visiblePages"`
			ShowBack                      bool  `json:"showBack"`
			ShowForward                   bool  `json:"showForward"`
			ShowFirstPageShortcut         bool  `json:"showFirstPageShortcut"`
			ShowFirstPageShortcutEllipsis bool  `json:"showFirstPageShortcutEllipsis"`
			ShowLastPageShortcut          bool  `json:"showLastPageShortcut"`
			ShowLastPageShortcutEllipsis  bool  `json:"showLastPageShortcutEllipsis"`
			AreMorePagesAvailable         bool  `json:"areMorePagesAvailable"`
		} `json:"pager"`
		TotalHits int `json:"totalHits"`
	} `json:"person"`
}

// type RatsitAutogenerated struct {
//   Snabbsok  bool        `json:"snabbSok"`
//   Text      interface{} `json:"text"`
//   Vemvarsok bool        `json:"vemVarSok"`
//   Vem       interface{} `json:"vem"`
//   Var       interface{} `json:"var"`
//   Person    struct {
//     Nysokning             bool `json:"nySokning"`
//     Visaantaltraffar      bool `json:"visaAntalTraffar"`
//     Flertraffar           bool `json:"flerTraffar"`
//     Antaltraffartotalt    int  `json:"antalTraffarTotalt"`
//     Antaltraffarbegransat bool `json:"antalTraffarBegransat"`
//     Nastatrafffran        int  `json:"nastaTraffFran"`
//     Antaldoldatraffar     int  `json:"antalDoldaTraffar"`
//     Isuservalidated       bool `json:"isUserValidated"`
//     Isuserpluscustomer    bool `json:"isUserPlusCustomer"`
//     List                  []struct {
//       Ishiddenperson        bool     `json:"isHiddenPerson"`
//       Lastnamecomplete      string   `json:"lastNameComplete"`
//       Hashiddenaddress      bool     `json:"hasHiddenAddress"`
//       Address               string   `json:"address"`
//       Postnr                string   `json:"postNr"`
//       Postort               string   `json:"postort"`
//       Isfemale              bool     `json:"isFemale"`
//       Hasrelation           bool     `json:"hasRelation"`
//       Age                   int      `json:"age"`
//       Personrapporturl      string   `json:"personrapportUrl"`
//       Givennames            []string `json:"givenNames"`
//       Names                 []string `json:"names"`
//       Hasbolagsengagemang   bool     `json:"hasBolagsengagemang"`
//       Antalbolagsengagemang int      `json:"antalBolagsengagemang"`
//     } `json:"list"`
//     Paging struct {
//       Totalpages               int         `json:"totalPages"`
//       Allowedpages             int         `json:"allowedPages"`
//       Visiblepageslowindex     int         `json:"visiblePagesLowIndex"`
//       Visiblepageshighindex    int         `json:"visiblePagesHighIndex"`
//       Pageindex                int         `json:"pageIndex"`
//       Hasnextpage              bool        `json:"hasNextPage"`
//       Haspreviouspage          bool        `json:"hasPreviousPage"`
//       Hasnextpageurl           interface{} `json:"hasNextPageUrl"`
//       Haspreviouspageurl       interface{} `json:"hasPreviousPageUrl"`
//       Showfirstshortcut        bool        `json:"showFirstShortcut"`
//       Showlastshortcut         bool        `json:"showLastShortcut"`
//       Showfirstshortcutelipsis bool        `json:"showFirstShortcutElipsis"`
//       Showlastshortcutelipsis  bool        `json:"showLastShortcutElipsis"`
//       Showloginformoremessage  bool        `json:"showLoginForMoreMessage"`
//     } `json:"paging"`
//   } `json:"person"`
//   Company struct {
//     Clientqueryid         int           `json:"clientQueryId"`
//     Nysokning             bool          `json:"nySokning"`
//     Visaantaltraffar      bool          `json:"visaAntalTraffar"`
//     Flertraffar           bool          `json:"flerTraffar"`
//     Antaltraffartotalt    int           `json:"antalTraffarTotalt"`
//     Antaltraffarbegransat bool          `json:"antalTraffarBegransat"`
//     Nastatrafffran        int           `json:"nastaTraffFran"`
//     List                  []interface{} `json:"list"`
//     Paging                struct {
//       Totalpages               int         `json:"totalPages"`
//       Allowedpages             int         `json:"allowedPages"`
//       Visiblepageslowindex     int         `json:"visiblePagesLowIndex"`
//       Visiblepageshighindex    int         `json:"visiblePagesHighIndex"`
//       Pageindex                int         `json:"pageIndex"`
//       Hasnextpage              bool        `json:"hasNextPage"`
//       Haspreviouspage          bool        `json:"hasPreviousPage"`
//       Hasnextpageurl           interface{} `json:"hasNextPageUrl"`
//       Haspreviouspageurl       interface{} `json:"hasPreviousPageUrl"`
//       Showfirstshortcut        bool        `json:"showFirstShortcut"`
//       Showlastshortcut         bool        `json:"showLastShortcut"`
//       Showfirstshortcutelipsis bool        `json:"showFirstShortcutElipsis"`
//       Showlastshortcutelipsis  bool        `json:"showLastShortcutElipsis"`
//       Showloginformoremessage  bool        `json:"showLoginForMoreMessage"`
//     } `json:"paging"`
//   } `json:"company"`
//   Personfilter struct {
//     Page                  int         `json:"page"`
//     Typ                   int         `json:"typ"`
//     Clientqueryid         int         `json:"clientQueryId"`
//     Trafffran             int         `json:"traffFran"`
//     Vem                   interface{} `json:"vem"`
//     Var                   interface{} `json:"var"`
//     Pnr                   string      `json:"pNr"`
//     Fnamn                 interface{} `json:"fNamn"`
//     Tnamn                 interface{} `json:"tNamn"`
//     Enamn                 interface{} `json:"eNamn"`
//     Coadress              interface{} `json:"coAdress"`
//     Fortsadress           interface{} `json:"fortsAdress"`
//     Gatuadress            interface{} `json:"gatuadress"`
//     Postnr                interface{} `json:"postNr"`
//     Postort               interface{} `json:"postOrt"`
//     Kommun                interface{} `json:"kommun"`
//     Telefon               interface{} `json:"telefon"`
//     Relation              bool        `json:"relation"`
//     Ejrelation            bool        `json:"ejRelation"`
//     Harbolagsengagemang   bool        `json:"harBolagsengagemang"`
//     Harejbolagsengagemang bool        `json:"harEjBolagsengagemang"`
//     Man                   bool        `json:"man"`
//     Kvinna                bool        `json:"kvinna"`
//     Alderfran             int         `json:"alderFran"`
//     Aldertill             int         `json:"alderTill"`
//     Fonetisksokning       bool        `json:"fonetiskSokning"`
//     Exaktsokning          bool        `json:"exaktSokning"`
//   } `json:"personFilter"`
//   Foretagfilter struct {
//     Typ                        int         `json:"typ"`
//     Clientqueryid              int         `json:"clientQueryId"`
//     Trafffran                  int         `json:"traffFran"`
//     Vem                        interface{} `json:"vem"`
//     Var                        interface{} `json:"var"`
//     Orgnr                      interface{} `json:"orgNr"`
//     Foretag                    interface{} `json:"foretag"`
//     Gatuadress                 interface{} `json:"gatuadress"`
//     Postnr                     interface{} `json:"postNr"`
//     Postort                    interface{} `json:"postOrt"`
//     Telefon                    interface{} `json:"telefon"`
//     Aktiebolag                 bool        `json:"aktiebolag"`
//     Enskildfirma               bool        `json:"enskildFirma"`
//     Handelsbolagkommanditbolag bool        `json:"handelsbolagKommanditbolag"`
//     Ovriga                     bool        `json:"ovriga"`
//     Fonetisksokning            bool        `json:"fonetiskSokning"`
//     Exaktsokning               bool        `json:"exaktSokning"`
//     Page                       int         `json:"page"`
//   } `json:"foretagFilter"`
//   Visaflik int `json:"visaFlik"`
// }

type RatsitPerson struct {
  RatsitID string
  ToAddress  string
  DisplayName string
  Context string `json:"@context"`
  Type    string `json:"@type"`
  Name    string `json:"name"`
  Address struct {
    Type            string `json:"@type"`
    AddressCountry  string `json:"addressCountry"`
    AddressLocality string `json:"addressLocality"`
    PostalCode      string `json:"postalCode"`
    StreetAddress   string `json:"streetAddress"`
  } `json:"address"`
  BirthDate  string `json:"birthDate"`
  FamilyName string `json:"familyName"`
  Gender     string `json:"gender"`
  GivenName  string `json:"givenName"`
  Telephone  string `json:"telephone"`
  Coordinates string `json:"coordinates"`
}

//type RatsitGeo struct {
//  Context   string `json:"@context"`
//  Type      string `json:"@type"`
//  Latitude  string `json:"latitude"`
//  Longitude string `json:"longitude"`
//}

type HittaPerson struct {
  HittaID       string        `json:"@foobar"`
  Context       string        `json:"@context"`
  Type          string        `json:"@type"`
  Name          string        `json:"name"`
  GivenName     string        `json:"givenName"`
  FamilyName    string        `json:"familyName"`
  Gender        string        `json:"gender"`
  BirthDate     string        `json:"birthDate"`
  AlternateName string        `json:"alternateName"`
  Nationality   string        `json:"nationality"`
  WorkFor       []interface{} `json:"workFor"`
  Address       struct {
    Type            string `json:"@type"`
    StreetAddress   string `json:"streetAddress"`
    AddressLocality string `json:"addressLocality"`
    AddressRegion   string `json:"addressRegion"`
    PostalCode      int    `json:"postalCode"`
    AddressCountry  struct {
      Type string `json:"@type"`
      Name string `json:"name"`
    } `json:"addressCountry"`
  } `json:"address"`
  Geo struct {
    Type      string  `json:"@type"`
    Latitude  float64 `json:"latitude"`
    Longitude float64 `json:"longitude"`
  } `json:"geo"`
}

const hittaurlroot = "https://www.hitta.se/person/"
const ratsiturlroot = "https://www.ratsit.se"

var useTor bool

// Check SQLite error
func checkErr(err error) {
  if err != nil {
    panic(err)
  }
}

type RatsitQuery struct {
	Who            string   `json:"who"`
	Age            []string `json:"age"`
	PhoneticSearch bool     `json:"phoneticSearch"`
	CompanyName    string   `json:"companyName"`
	OrgNr          string   `json:"orgNr"`
	FirstName      string   `json:"firstName"`
	LastName       string   `json:"lastName"`
	PersonNumber   string   `json:"personNumber"`
	Phone          string   `json:"phone"`
	Address        string   `json:"address"`
	Postnr         string   `json:"postnr"`
	Postort        string   `json:"postort"`
	Kommun         string   `json:"kommun"`
	Page           int      `json:"page"`
}

func fromRatsitAPI(theFirst string, theLast string, theSSN string, theCity string) (string) {
  // Example: {"who":"patrik fältström","age":["16","120"],"phoneticSearch":true,"companyName":"","orgNr":"","firstName":"","lastName":"","personNumber":"","phone":"","address":"","postnr":"","postort":"","kommun":"","page":1}

  theURL := "https://www.ratsit.se/api/search/combined"
  q := RatsitQuery{}
  q.PhoneticSearch = false
  q.Age = []string{"16","120"}
  q.Who = theFirst + " " + theLast
  // q.FirstName = theFirst
  // q.LastName = theLast
  q.PersonNumber = theSSN
  q.Postort = theCity
  q.Page = 1
  
  //values := map[string]{"who": "", "age":{16,120}, "phoneticSearch":true, "companyName":"", "orgNr":"", "firstName": theFirst, "lastName": theLast, "personNumber": theSSN, "phone":"", "address":"", "postnr":"", "postort":theCity, "kommun":"","page":1}
  //json_data, err := json.Marshal(values)
  //if err != nil {
  //  log.Fatal(err)
  //}

  //val, err := json.MarshalIndent(q, "", "    ")
  //fmt.Printf("%s\n",val)
  //os.Exit(1)

  spaceClient := http.Client{
    Timeout: time.Second * 10, // Timeout after 2 seconds
  }

  json_data, err := json.Marshal(q)
  req, err := http.NewRequest(http.MethodPost, theURL, bytes.NewBuffer(json_data))
  req.Header.Add("content-type", "application/json; charset=utf-8")

  if(useTor) {
    // Set up a SOCKS5 proxy dialer for Tor
    dialer, err := proxy.SOCKS5("tcp", "localhost:9050", nil, proxy.Direct)
    if err != nil {
      log.Fatal(err)
    }

    // Create a transport that uses the dialer
    transport := &http.Transport{Dial: dialer.Dial}

    spaceClient.Transport = transport
  }

  resp, err := spaceClient.Do(req)
  if err != nil {
    log.Fatal(err)
  }

  //respDump, err := httputil.DumpResponse(resp, true)
  //if err != nil {
  //  log.Fatal(err)
  //}

  //fmt.Printf("RESPONSE:\n%s\n", string(respDump))

  //var res map[string]interface{}
  
  //json.NewDecoder(resp.Body).Decode(&res)

  //fmt.Println(res["json"])

  // Parse the JSON response
  apiResponse := RatsitAutogenerated{}
  json.NewDecoder(resp.Body).Decode(&apiResponse)
  //jsonErr := json.Unmarshal([]byte(body), &apiResponse)
  //jsonErr := json.Unmarshal(, &apiResponse)
  //if jsonErr != nil {
  //  log.Fatal(jsonErr)
  //}
  //val, err := json.MarshalIndent(apiResponse, "", "    ")
  //fmt.Printf("%s\n",val)
  if apiResponse.Person.TotalHits == 0 {
    fmt.Printf("No hits\n")
  }
  if apiResponse.Person.TotalHits > len(apiResponse.Person.Hits) {
    fmt.Printf("Showing first %d records of %d\n", len(apiResponse.Person.Hits), apiResponse.Person.TotalHits)
  } else if len(apiResponse.Person.Hits) > 1 {
    fmt.Printf("Found %d records\n", len(apiResponse.Person.Hits))
  }
  recordNo := -1
  if len(apiResponse.Person.Hits) == 1 {
    recordNo = 0
  } else if len(apiResponse.Person.Hits) > 1 {
    for i, s := range apiResponse.Person.Hits {
      if(s.Hidden) {
        fmt.Printf("%d: Hidden\n", i)
      } else {
        fmt.Printf("%d: %d år, %s %s, %s, %s\n", i, s.Age, s.FirstName, s.LastName, s.StreetAddress, s.City)
      }
    }
    reader := bufio.NewReader(os.Stdin)
    fmt.Print("Choose person: ")
    ans, _ := reader.ReadString('\n')
    recordNo, err = strconv.Atoi(strings.TrimSpace(ans))
    if(err == nil && recordNo >=0 && recordNo < len(apiResponse.Person.Hits)) {
      //fmt.Printf("Selected record %d\n", recordNo)
    } else {
      fmt.Printf("No record selected\n")
      recordNo = -1
    }
  }

  // Check if we got a record selected
  if(recordNo >= 0) {
    theTokens := strings.Split(apiResponse.Person.Hits[recordNo].PersonURL, "/")
    //fmt.Printf("ID: [%s] %s\n", apiResponse.Person.Hits[recordNo].PersonURL, theTokens[4])
    return(theTokens[4])
  } else {
    return("")
  }
}

func fromRatsit(theRatsitID string) (RatsitPerson, error) {
  horoscopeRoot := "https://www.ratsit.se/person/horoskop/"
  theHoroscopeURL := horoscopeRoot + theRatsitID

  spaceClient := http.Client{
    Timeout: time.Second * 10, // Timeout after 10 seconds
  }

  if(useTor) {
    // Set up a SOCKS5 proxy dialer for Tor
    dialer, err := proxy.SOCKS5("tcp", "localhost:9050", nil, proxy.Direct)
    if err != nil {
      log.Fatal(err)
    }

    // Create a transport that uses the dialer
    transport := &http.Transport{Dial: dialer.Dial}

    spaceClient.Transport =  transport
  }

  // fmt.Println("H-URL: ", theHoroscopeURL)
  req, err := http.NewRequest(http.MethodGet, theHoroscopeURL, nil)
  if err != nil {
    log.Fatal(err)
  }

  //req.Header.Set("User-Agent", "paf-adress")
  res, getErr := spaceClient.Do(req)
  if getErr != nil {
    log.Fatal(getErr)
  }

  if res.Body != nil {
    defer res.Body.Close()
  }

  body, readErr := ioutil.ReadAll(res.Body)
  if readErr != nil {
    log.Fatal(readErr)
  }
  //fmt.Println(string(body))
  person := RatsitPerson{}
  // Note: the .*? construction is a non-greedy match, .* is greedy (longest) match
  theRegexp := `"(https://www.ratsit.se/.*?/` + theRatsitID + `)">`
  rgx := regexp.MustCompile(theRegexp)
  rs := rgx.FindStringSubmatch(string(body))
  if len(rs) == 0 {
    return person, errors.New("Did not find person with that id")
  }
  if len(rs) > 0 {
    personURL := rs[1]
    req, err = http.NewRequest(http.MethodGet, personURL, nil)
    if err != nil {
      log.Fatal(err)
    }
    res, getErr = spaceClient.Do(req)
    if getErr != nil {
      log.Fatal(getErr)
    }
    if res.Body != nil {
      defer res.Body.Close()
    }
    body, readErr = ioutil.ReadAll(res.Body)
    if readErr != nil {
      log.Fatal(readErr)
    }

    // Extract the JSON from the webpage
    rgx = regexp.MustCompile(`(?s)application\/ld\+json.*?\[(\{.*\}),(\{.*?\})\]`)
    rs = rgx.FindStringSubmatch(string(body))
    if len(rs) > 0 {
      //fmt.Println("debug:", rs)
      jsonErr := json.Unmarshal([]byte(rs[1]), &person)
      if jsonErr != nil {
        log.Fatal(jsonErr)
      }
      //jsonErr = json.Unmarshal([]byte(rs[2]), &geo)
      //if jsonErr != nil {
      //  log.Fatal(jsonErr)
      //}
    }
  }

  if len(person.Name) > 0 {
    rea := regexp.MustCompile(`^0(.*)$`)
    reb := regexp.MustCompile(`^\+46([0-9].*)$`)
    person.Telephone = rea.ReplaceAllString(person.Telephone, `+46-$1`)
    person.Telephone = reb.ReplaceAllString(person.Telephone, `+46-$1`)
    person.RatsitID = theRatsitID
    person.Coordinates = ""
    return person, nil
  } else {
    return person, errors.New("Did not find person")
  }
}

func fromHitta(theid string) (HittaPerson, error) {
  url := hittaurlroot + theid

  spaceClient := http.Client{
    Timeout: time.Second * 2, // Timeout after 2 seconds
  }

  req, err := http.NewRequest(http.MethodGet, url, nil)
  if err != nil {
    log.Fatal(err)
  }

  //req.Header.Set("User-Agent", "paf-adress")

  res, getErr := spaceClient.Do(req)
  if getErr != nil {
    log.Fatal(getErr)
  }

  if res.Body != nil {
    defer res.Body.Close()
  }

  body, readErr := ioutil.ReadAll(res.Body)
  if readErr != nil {
    log.Fatal(readErr)
  }

  person := HittaPerson{}
  rgx := regexp.MustCompile(`application/ld\+json\"\>([^<]*)\<`)
  rs := rgx.FindStringSubmatch(string(body))
  if len(rs) > 0 {
    jsonErr := json.Unmarshal([]byte(rs[1]), &person)
    if jsonErr != nil {
      log.Fatal(jsonErr)
    }
  }
  if len(person.Name) > 0 {
    return person, nil
  } else {
    return person, errors.New("Did not find person")
  }
}

// Initialize the sqlite3 database
func incsqlite(filename string) (*sql.DB){
  theDB, err := sql.Open("sqlite", filename)
  checkErr(err)
  stmt, err := theDB.Prepare("CREATE TABLE IF NOT EXISTS person (ratsitID TEXT, name TEXT, givenname TEXT, familyname TEXT, telephone TEXT, gender TEXT, birthdate TEXT, streetaddress TEXT, addresslocality TEXT, addresscountry TEXT, postalcode TEXT, latitude TEXT, longitude TEXT, coordinates TEXT, displayname TEXT, toaddress TEXT)")
  checkErr(err)
  _, err = stmt.Exec()
  checkErr(err)
  //stmt, err = theDB.Prepare("CREATE UNIQUE INDEX IF NOT EXISTS ipaddrindex ON ipaddr (prefix, ipaddr, port, protocol)")
  //checkErr(err)
  //_, err = stmt.Exec()
  //checkErr(err)
  return theDB
}

func doAddRatsit(theDB *sql.DB, theID string, p RatsitPerson) {
  _, err := theDB.Exec("INSERT INTO person (ratsitID, name, givenname, familyname, telephone, gender, birthdate, streetaddress, addresslocality, addresscountry, postalcode, coordinates, displayname, toaddress) values (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)", theID, p.Name, p.GivenName, p.FamilyName, p.Telephone, p.Gender, p.BirthDate, p.Address.StreetAddress, p.Address.AddressLocality, p.Address.AddressCountry, p.Address.PostalCode, p.Coordinates, p.DisplayName, p.ToAddress)
  checkErr(err)
}

func doDeleteRatsit(theDB *sql.DB, theID string) {
  _, err := theDB.Exec("DELETE FROM person WHERE ratsitID = ?", theID)
  checkErr(err)
}

func fromDB(theDB *sql.DB, theID string) (RatsitPerson, error) {
  var pa []RatsitPerson
  var p RatsitPerson

  rows,err := theDB.Query("SELECT ratsitID, name, givenname, familyname, telephone, gender, birthdate, streetaddress, addresslocality, addresscountry, postalcode, coordinates, displayname, toaddress FROM person WHERE ratsitID = ?", theID)
  checkErr(err)
  defer rows.Close()
  for rows.Next() {
    if err := rows.Scan(&(p.RatsitID), &(p.Name), &(p.GivenName), &(p.FamilyName), &(p.Telephone), &(p.Gender), &(p.BirthDate), &(p.Address.StreetAddress), &(p.Address.AddressLocality), &(p.Address.AddressCountry), &(p.Address.PostalCode), &(p.Coordinates), &(p.DisplayName), &(p.ToAddress)); err != nil {
      checkErr(err)
    }
    //p.RatsitID = theID
    pa = append(pa, p)
  }
  if len(pa) > 0 {
    return pa[0], nil
  } else {
    return p, errors.New("Did not find person")
  }
}

func searchDB(theDB *sql.DB, theID string, theGivenName string, theFamilyName string, theCity string, theBirthdate string) ([]RatsitPerson, error) {
	var pa []RatsitPerson
	var p RatsitPerson
  theQuery := "SELECT ratsitID, name, givenname, familyname, telephone, gender, birthdate, streetaddress, addresslocality, addresscountry, postalcode, coordinates, displayname, toaddress FROM person WHERE "
  theQuery = theQuery + "ratsitID like '%" + theID + "%'"
  theQuery = theQuery + "and givenname like '%" + theGivenName + "%'"
  theQuery = theQuery + "and familyname like '%" + theFamilyName + "%'"
  theQuery = theQuery + "and addresslocality like '%" + theCity + "%'"
  theQuery = theQuery + "and birthdate like '%" + theBirthdate + "%'"
  theQuery = theQuery + "order by familyname, givenname"
  //fmt.Printf("Looking for %s, %s, %s, %s\n", theGivenName, theFamilyName, theCity, theBirthdate)
  rows,err := theDB.Query(theQuery)
  //	rows,err := theDB.Query("SELECT ratsitID, name, givenname, familyname, telephone, gender, birthdate, streetaddress, addresslocality, addresscountry, postalcode FROM person WHERE givenname like ? and familyname like ? and addresslocality like ? and birthdate like ?", theGivenName, theFamilyName, theCity, theBirthdate)
	checkErr(err)
	defer rows.Close()
	for rows.Next() {
		if err := rows.Scan(&(p.RatsitID), &(p.Name), &(p.GivenName), &(p.FamilyName), &(p.Telephone), &(p.Gender), &(p.BirthDate), &(p.Address.StreetAddress), &(p.Address.AddressLocality), &(p.Address.AddressCountry), &(p.Address.PostalCode), &(p.Coordinates), &(p.DisplayName), &(p.ToAddress)); err != nil {
			checkErr(err)
		}

		pa = append(pa, p)
	}
  if len(pa) > 0 {
    return pa, nil
  } else {
    return pa, errors.New("Did not find any person")
  }
}

func searchBirthdayDB(theDB *sql.DB, days int) ([]RatsitPerson, error) {
  var pa []RatsitPerson
  var p RatsitPerson
  td := time.Now()
  theQuery := "SELECT ratsitID, name, givenname, familyname, telephone, gender, birthdate, streetaddress, addresslocality, addresscountry, postalcode, coordinates, displayname, toaddress FROM person WHERE "
  theQuery = theQuery + "birthdate like '%-" + fmt.Sprintf("%02d-%02d", td.Month(), td.Day()) + "'"
  for i := -1; i < days; i++ {
    td = td.AddDate(0, 0, 1)
    theQuery = theQuery + "or birthdate like '%-" + fmt.Sprintf("%02d-%02d", td.Month(), td.Day()) + "'"
  }
  theQuery = theQuery + " order by substr(birthdate, 6, 5)"
  //fmt.Println(theQuery)
  rows,err := theDB.Query(theQuery)
  checkErr(err)
  defer rows.Close()
  for rows.Next() {
    if err := rows.Scan(&(p.RatsitID), &(p.Name), &(p.GivenName), &(p.FamilyName), &(p.Telephone), &(p.Gender), &(p.BirthDate), &(p.Address.StreetAddress), &(p.Address.AddressLocality), &(p.Address.AddressCountry), &(p.Address.PostalCode), &(p.Coordinates), &(p.DisplayName), &(p.ToAddress)); err != nil {
      checkErr(err)
    }
    pa = append(pa, p)
  }
  if len(pa) > 0 {
    return pa, nil
  } else {
    return pa, errors.New("Did not find any person")
  }
}

func main() {

  // Init database
  dbfilepath := "/Users/paf/Documents/addressbook.sqlite"
  theDB := incsqlite(dbfilepath)

  // Handle arguments
  idPtr := flag.String("id", "", "a unique id for a record")
  //hittaPtr := flag.String("hitta", "", "use Hitta")
  addBool := flag.Bool("add", false, "add record")
  findBool := flag.Bool("find", false, "find records online")
  diffBool := flag.Bool("diff", false, "compare records")
  toorBool := flag.Bool("tor", false, "use local TOR socks proxy")
  useTor = *toorBool
  birthdayNum := flag.Int("birthday", -1, "who has birthday soon")
  sheetsBool := flag.Bool("sheets", false, "sync with google sheets")
  fixBool := flag.Bool("fix", false, "various fixes")
  sheetsXY := flag.String("xy", "-", "A:1 form of coordinates of first address line")
  sheetsBrutal := flag.Bool("brutal", false, "update coordinates from address in sheet")
  sheetsFetch := flag.Bool("fetch", false, "update data from sheet")
  ratsitFirstName := flag.String("first", "", "the first name of the person")
  ratsitLastName := flag.String("last", "", "the last name of the person")
  ratsitCity := flag.String("city", "", "the city the person lives in")
  ratsitSSN := flag.String("ssn", "", "the swedish social security number (YYYYMMDDNNNN)")
  flag.Parse()

  recommendBrutal := false
  
  // If we are looking for future birthdays
  if(*birthdayNum >= 0) {
    ratsitpersons, _ := searchBirthdayDB(theDB, *birthdayNum)
    if(len(ratsitpersons) > 0) {
      for _, s := range ratsitpersons {
        fmt.Printf("%s, %s, %s, %s %s, %s\n",s.BirthDate, s.Name, s.Address.StreetAddress, s.Address.PostalCode, s.Address.AddressLocality, s.Telephone);
      }
    }
    return
  }

  // If we are looking for interaction with Google Sheets
  if(*sheetsBool) {
    fmt.Printf("--> Connect to Google\n");
    // Init Google Sheets Interaction
    haveChanged := false
    sheetsData, err := ioutil.ReadFile("/Users/paf/Documents/addressbook-cred.json")
    if(err != nil) {
      panic(err.Error())
    }
    sheetsConf, err := google.JWTConfigFromJSON(sheetsData, spreadsheet.Scope)
    if(err != nil) {
      panic(err.Error())
    }
    sheetsClient := sheetsConf.Client(context.TODO())
    sheetsService := spreadsheet.NewServiceWithClient(sheetsClient)
    spreadsheet, err := sheetsService.FetchSpreadsheet("1sNC-gSgdSsrA5jCCYwaNaTPtEuM5FqNtFFqB_bJRAWQ")
    if(err != nil) {
      panic(err.Error())
    }
    sheet, err := spreadsheet.SheetByIndex(0)
    maxRows := len(sheet.Rows)

    if(err != nil) {
      panic(err.Error())
    }
    // Google sheets is ready, now lets do some stuff
    fmt.Printf("--> Google is ready\n");
    // Update coordinates from sheets, just match on street address
    // Records are in columns 0, 1 and 2
    if(*sheetsFetch) {
      fmt.Printf("--> We are in Sheet Fetch mode\n");
      noRecord := 0 // Start with record 0
      noRow := 0 // First record on row 0
      noColumn := 0 // First record on column 0
      for(noRecord < (maxRows / 6) * 3) {
        noInnerRow := 0
        var myArray [6]string
        for(noInnerRow < 6) {
          theValue := sheet.Rows[noRow + noInnerRow][noColumn].Value
          myArray[noInnerRow] = theValue
          noInnerRow = noInnerRow + 1
        }
        theRow := 6

        theCountry := ""
        theZip := ""
        theCity := ""
        theAddressOne := ""
        //theAddressTwo := ""
        theToLine := ""
        
        // Regular expression for a zip code in Sweden
        SEpattern := "^([0-9][0-9][0-9] [0-9][0-9]) (.*)$"
        SEregex := regexp.MustCompile(SEpattern)

        // USA Henderson, NV 89052
        USApattern := "^(.*, [A-Z][A-Z]) (.*)$"
        USAregex := regexp.MustCompile(USApattern)

        // Italy 63074 San Benedetto del Tronto AP
        Italypattern := "^([0-9]*) (.*)$"
        Italyregex := regexp.MustCompile(Italypattern)

        // UK SW14 7LY London
        UKpattern := "^(.*) ([A-Za-z]*)$"
        UKregex := regexp.MustCompile(UKpattern)
        
        for(theRow > 0) {
          theRow = theRow - 1
          if(myArray[theRow] != "") {
            if(theCountry == "") {
              matches := SEregex.FindStringSubmatch(myArray[theRow])
              if(len(matches) > 0) {
                // If this did match, this is a Swedish zip code and city
                theZip = matches[1]
                theCity = matches[2]
                theCountry = "Sweden"
              } else {
                theCountry = myArray[theRow]
              }
              if(theCountry == "Sweden") {
                theCountry = "SE"
              }
              if(theCountry == "USA") {
                theCountry = "US"
                theRow = theRow - 1
                matches := USAregex.FindStringSubmatch(myArray[theRow])
                if(len(matches) > 0) {
                  theZip = matches[2]
                  theCity = matches[1]
                } else {
                  fmt.Printf("WTF USA: %s\n", myArray[theRow])
                }
              }
              if(theCountry == "RUSSIA") {
                theCountry = "RU"
                theRow = theRow - 1
                theRegion := myArray[theRow]
                theRow = theRow - 1
                matches := Italyregex.FindStringSubmatch(myArray[theRow])
                if(len(matches) > 0) {
                  theZip = matches[1]
                  theCity = matches[2] + "//" + theRegion
                } else {
                  fmt.Printf("WTF Russia: %s\n", myArray[theRow])
                }
              }
              if(theCountry == "Australia") {
                theCountry = "AU"
                theRow = theRow - 1
                matches := Italyregex.FindStringSubmatch(myArray[theRow])
                if(len(matches) > 0) {
                  theZip = matches[1]
                  theCity = matches[2]
                } else {
                  fmt.Printf("WTF Australia: %s\n", myArray[theRow])
                }
              }
              if(theCountry == "ITALY") {
                theCountry = "IT"
                theRow = theRow - 1
                matches := Italyregex.FindStringSubmatch(myArray[theRow])
                if(len(matches) > 0) {
                  theZip = matches[1]
                  theCity = matches[2]
                } else {
                  fmt.Printf("WTF Italy: %s\n", myArray[theRow])
                }
              }
              if(theCountry == "DENMARK") {
                theCountry = "DK"
                theRow = theRow - 1
                matches := Italyregex.FindStringSubmatch(myArray[theRow])
                if(len(matches) > 0) {
                  theZip = matches[1]
                  theCity = matches[2]
                } else {
                  fmt.Printf("WTF Denmark: %s\n", myArray[theRow])
                }
              }
              if(theCountry == "FRANCE") {
                theCountry = "FR"
                theRow = theRow - 1
                matches := Italyregex.FindStringSubmatch(myArray[theRow])
                if(len(matches) > 0) {
                  theZip = matches[1]
                  theCity = matches[2]
                } else {
                  fmt.Printf("WTF France: %s\n", myArray[theRow])
                }
              }
              if(theCountry == "Switzerland") {
                theCountry = "CH"
                theRow = theRow - 1
                matches := Italyregex.FindStringSubmatch(myArray[theRow])
                if(len(matches) > 0) {
                  theZip = matches[1]
                  theCity = matches[2]
                } else {
                  fmt.Printf("WTF Switzerland: %s\n", myArray[theRow])
                }
              }
              if(theCountry == "England") {
                theCountry = "UK"
                theRow = theRow - 1
                matches := UKregex.FindStringSubmatch(myArray[theRow])
                if(len(matches) > 0) {
                  theZip = matches[1]
                  theCity = matches[2]
                } else {
                  fmt.Printf("WTF UK: %s\n", myArray[theRow])
                }
              }
              if(theCountry == "Canada") {
                theCountry = "CA"
                theRow = theRow - 1
                matches := USAregex.FindStringSubmatch(myArray[theRow])
                if(len(matches) > 0) {
                  theZip = matches[2]
                  theCity = matches[1]
                } else {
                  fmt.Printf("WTF Canada: %s\n", myArray[theRow])
                }
              }
            } else if(theAddressOne == "") {
              theAddressOne = myArray[theRow]
            } else {
              theToLine = myArray[theRow]
            } 
          }
        }
        fmt.Printf("%s\n", theToLine)
        fmt.Printf("%s\n", theAddressOne)
        fmt.Printf("%s %s\n", theZip, theCity)
        fmt.Printf("%s\n", theCountry)

        rowCount := 0
        allRows, err := theDB.Query("Select rowid from person where streetaddress = ?", theAddressOne)
        checkErr(err)
        defer allRows.Close()
        for allRows.Next() {
          theRowid := 0
          rowCount++
          allRows.Scan(&(theRowid))
          fmt.Printf("Row %d\n\n", theRowid)
        }
        if(rowCount == 0) {
          if(theCountry == "SE") {
            fmt.Printf("WTF Sweden!\n")
          }
          fmt.Printf("No record found!\n")
          if(len(theToLine) > 0) {
            fmt.Printf("Adding record to database...\n")
            var p RatsitPerson
            p.RatsitID = ""
            p.DisplayName = theToLine
            p.ToAddress = theAddressOne
            p.Name = theToLine
            p.GivenName = theToLine
            p.FamilyName = theToLine
            p.Telephone = ""
            p.Gender = ""
            p.BirthDate = ""
            p.Address.StreetAddress = theAddressOne
            p.Address.AddressLocality = theCity
            p.Address.AddressCountry = theCountry
            p.Address.PostalCode = theZip
            p.Coordinates = ""
            p.DisplayName = theToLine
            p.ToAddress = theToLine
            doAddRatsit(theDB, p.RatsitID, p)
          }
        }
        noRecord++
        noColumn++
        if(noColumn > 2) {
          noColumn = 0
          noRow = noRow + 6
        }
      }
      return
    }
    if(*sheetsBrutal) {
      fmt.Printf("--> We are in Sheet Brutal mode\n");
      noRow := 1 // We can start on 2nd row
      for(noRow < (maxRows-1)) {
        noColumn := 0
        for(noColumn < 3) {
          theValue := sheet.Rows[noRow][noColumn].Value
          if(theValue != "X" && theValue != "") {
            // Whats the coordinates?
            theColumn := string(noColumn + 65)
            // We can use the row, as row in address start with 1,
            // while index starts with 0, and we want previous line
            theCoordinates := fmt.Sprintf("%s%d", theColumn, noRow)
            // Set coordinates for all records value == address
            fmt.Printf("--> Update coordinates for address %s\n", theValue);
            _, err := theDB.Exec("UPDATE person SET coordinates = ? WHERE streetaddress = ?", theCoordinates, theValue)
            checkErr(err)
          }
          noColumn = noColumn + 1
        }
        noRow = noRow + 1
      }
      return
    }
    
    // Look up the person(s)
    ratsitpersons, _ := searchDB(theDB, *idPtr, *ratsitFirstName, *ratsitLastName, *ratsitCity, *ratsitSSN)
    // If no person found, exit
    if(len(ratsitpersons) == 0) {
      fmt.Printf("No match\n")
      return
    }

    // Regular expression for the coordinates
    rgx := regexp.MustCompile(`^([A-Z])([0-9]+)$`)

    // List records if have one or more persons
    if(!*addBool && !*diffBool) {
      for _, s := range ratsitpersons {
        // Check if the person do have coordinates
        if(s.Coordinates == "") {
          fmt.Printf("--> Coordinates missing for %s\n", s.Name);
          if(!*fixBool) {
            fmt.Printf("NO %s, %s, %s %s\n", s.Name, s.Address.StreetAddress, s.Address.PostalCode, s.Address.AddressLocality)
            recommendBrutal = true
          } else {
            newRow := 1
            newColumn := 0
            foundPosition := false
            for(!foundPosition) {
              if(sheet.Rows[newRow][newColumn].Value == "") {
                foundPosition = true
              } else {
                newColumn = newColumn + 1
                if(newColumn > 2) {
                  newColumn = 0
                  newRow = newRow + 6
                }
                if(newRow > maxRows) {
                  maxRows = maxRows + 6
                  fmt.Printf("Expanding sheet from %d to %d rows\n", maxRows-6,maxRows)
                  err := sheetsService.ExpandSheet(sheet, uint(maxRows), 3)
                  if(err != nil) {
                    fmt.Printf("What?\n")
                    panic(err.Error())
                  }
                  foundPosition = true
                }
              }
            }
            sheet.Update(newRow, newColumn, s.Name)
            sheet.Update(newRow+1, newColumn, s.Address.StreetAddress)
            sheet.Update(newRow+2, newColumn, s.Address.PostalCode + " " + s.Address.AddressLocality)
            haveChanged = true
            fmt.Printf("Added record %s\n", s.Name)
          }
        } else {
          if(!*fixBool) {
            fmt.Printf("%s, %s, %s %s %s\n", s.Name, s.Address.StreetAddress, s.Address.PostalCode, s.Address.AddressLocality, s.Coordinates)
          }
          rs := rgx.FindStringSubmatch(s.Coordinates)
          if(len(rs) > 0) {
            // Convert from letter/digit format column/row to row/column int
            theColumn := int(rs[1][0]) - int('A')
            theRow, _ := strconv.Atoi(rs[2])
            theRow = theRow - 1
            if(theRow < maxRows) {
              oneName := sheet.Rows[theRow][theColumn].Value
              oneAddress := sheet.Rows[theRow+1][theColumn].Value
              onePostal := sheet.Rows[theRow+2][theColumn].Value
              if(!*fixBool) {
                fmt.Printf("%s, %s, %s\n", oneName, oneAddress, onePostal)
              }
            }
          } else {
            fmt.Printf("Weird coordinates (%s) for person %s\n", s.Coordinates, s.Name)
          }
        }
      }
      if(recommendBrutal){
        fmt.Printf("Recommend argument -brutal\n")
      }
    }
    // If XY coordinates are given but empty string, remove them from database
    if(len(*sheetsXY) == 0) {
      if(len(ratsitpersons) > 1) {
        fmt.Printf("Can not update coordinates of more than one record\n")
        return
      }
      thePerson := ratsitpersons[0]
      if(thePerson.Coordinates != "") {
        fmt.Printf("Removing coordinates from person %s\n", thePerson.Name)
      }
      doDeleteRatsit(theDB, thePerson.RatsitID)
      thePerson.Coordinates = ""
      doAddRatsit(theDB, thePerson.RatsitID, thePerson)
    }
    // If XY coordinates are given, add them for the person
    if(len(*sheetsXY) > 0 && *sheetsXY != "-") {
      if(len(ratsitpersons) >1) {
        fmt.Printf("Can not update coordinates of more than one record\n")
        return
      }
      thePerson := ratsitpersons[0]
      fmt.Printf("Updating coordinates for person %s %s\n", thePerson.Name, thePerson.Coordinates)
      // We want CAPS for the column value
      theXY := strings.ToUpper(*sheetsXY)
      // Validate syntax of coordinates ([A-Z][0-9]+)
      rs := rgx.FindStringSubmatch(theXY)
      if(len(rs) > 0) {
        if(thePerson.Coordinates == "") {
          fmt.Printf("Adding coordinates (%s) for person %s\n", theXY, thePerson.Name)
        } else {
          fmt.Printf("Updating coordinates to become (%s) for person %s\n", theXY, thePerson.Name)
        }
        doDeleteRatsit(theDB, thePerson.RatsitID)
        thePerson.Coordinates = theXY
        doAddRatsit(theDB, thePerson.RatsitID, thePerson)
      } else {
        fmt.Printf("Weird coordinates (%s)\n", *sheetsXY)
      }
    }
    // Add / update sheet from record
    if(*addBool || *diffBool) {
      for _, s := range ratsitpersons {
        rs := rgx.FindStringSubmatch(s.Coordinates)
        if(len(rs) > 0) {
          // Convert from letter/digit format column/row to row/column int
          theColumn := int(rs[1][0]) - int('A')
          theRow, _ := strconv.Atoi(rs[2])
          theRow = theRow - 1
          // Fetch the three lines from the sheet
          if(theRow > maxRows) {
            fmt.Printf("Wrong coordinates for %s\n", s.Name)
            return
          }
          // if(theRow+5 < maxRows) {
          //  maxRows = maxRows + 6
          //  fmt.Printf("Update and expanding sheet from %d to %d rows\n", maxRows-6,uint(maxRows))
          //  sheetsService.ExpandSheet(sheet, uint(maxRows), 3)
          //  sheetsService.SyncSheet(sheet)
          // }
          oneName := sheet.Rows[theRow][theColumn].Value
          oneAddress := sheet.Rows[theRow+1][theColumn].Value
          onePostal := sheet.Rows[theRow+2][theColumn].Value
          // Fetch the three values from the database
          theName := s.Name
          // fmt.Printf("Checking person %s\n", theName)
          theAddress := s.Address.StreetAddress
          thePostal := s.Address.PostalCode + " " + s.Address.AddressLocality
          // Compare with the record in the database, and update if requested
          if(oneAddress != theAddress || onePostal != thePostal) {
            if(*addBool) {
              sheet.Update(theRow+1,theColumn, theAddress)
              sheet.Update(theRow+2,theColumn, thePostal)
              haveChanged = true
            }
            fmt.Printf("[%d, %d]\n", theRow, theColumn)
            fmt.Printf("OLD: %s, %s, %s\n", oneName, oneAddress, onePostal)
            fmt.Printf("NEW: %s, %s, %s\n", theName, theAddress, thePostal)
          }
        }
      }
    }
    // If the google sheet has changed, sync
    if(haveChanged) {
      err = sheet.Synchronize()
      if(err != nil) {
        fmt.Printf("Error Sync\n")
        panic(err.Error())
      }
    }
    return
  }

  // If we have not asked for lookup of records online
  if(!(*findBool) && !(*diffBool)) {
    ratsitpersons, _ := searchDB(theDB, *idPtr, *ratsitFirstName, *ratsitLastName, *ratsitCity, *ratsitSSN)
    //fmt.Printf("%d found\n", len(ratsitpersons))
    if(len(ratsitpersons) > 0) {
      for _, s := range ratsitpersons {
        fmt.Printf("%s, %s, %s, %s %s, %s %s\n",s.BirthDate, s.Name, s.Address.StreetAddress, s.Address.PostalCode, s.Address.AddressLocality, s.Telephone, s.Coordinates);
      }
    }
    return
  }

  // If we have asked for a diff to be made
  if(*diffBool) {
    ratsitpersons, _ := searchDB(theDB, *idPtr, *ratsitFirstName, *ratsitLastName, *ratsitCity, *ratsitSSN)
    //fmt.Printf("%d found\n", len(ratsitpersons))
    if(len(ratsitpersons) > 0) {
      for _, s := range ratsitpersons {
        if(s.RatsitID == "") {
          fmt.Printf("Will not check %s in Ratsit\n",s.Name)
          continue
        }
        // Do not dos the service, pause 1s between each call
        time.Sleep(1 * time.Second)
        fmt.Printf("Checking %s...", s.Name)
        t, err := fromRatsit(s.RatsitID)
        if(err != nil) {
          fmt.Printf("MISSING!\nMISSING: %s, %s, %s, %s %s, %s\n",s.BirthDate, s.Name, s.Address.StreetAddress, s.Address.PostalCode, s.Address.AddressLocality, s.Telephone);
          fmt.Printf("===========================\n")
        } else {
          if(s.Name == t.Name &&
            s.Address.StreetAddress == t.Address.StreetAddress &&
            s.Address.PostalCode == t.Address.PostalCode &&
            s.Address.AddressLocality == t.Address.AddressLocality &&
            s.Telephone == t.Telephone) {
            fmt.Printf("ok\n")
          } else {
            fmt.Printf("\nOLD: %s, %s, %s, %s %s, %s\n",s.BirthDate, s.Name, s.Address.StreetAddress, s.Address.PostalCode, s.Address.AddressLocality, s.Telephone);
            fmt.Printf("NEW: %s, %s, %s, %s %s, %s\n",t.BirthDate, t.Name, t.Address.StreetAddress, t.Address.PostalCode, t.Address.AddressLocality, t.Telephone);
            // If we have asked for the record to be updated, delete and add again
            if(*addBool) {
              t.Coordinates = s.Coordinates
              doDeleteRatsit(theDB, s.RatsitID)
              doAddRatsit(theDB, s.RatsitID, t)
              fmt.Printf("UPDATED\n")
            }
            fmt.Printf("===========================\n")
          }
        }
      }
    }
    return
  }

  // If we are looking for records in Ratsit
  var getRatsitPerson RatsitPerson
  var fetcherr error

  ratsitID := *idPtr
  // If we do not have any RatsitID yet, do a search
  if(len(ratsitID) == 0) {
    ratsitID = fromRatsitAPI(*ratsitFirstName, *ratsitLastName, *ratsitSSN, *ratsitCity)
  }

  if len(ratsitID) > 0 {
    getRatsitPerson, fetcherr = fromRatsit(ratsitID)
  }
  if fetcherr != nil {
    log.Fatal("Did not find person with ID ",ratsitID)
  }
  if(len(ratsitID) > 0) {
    fmt.Printf("ID: %s\n", getRatsitPerson.RatsitID)
    fmt.Printf("Name: %s\n", getRatsitPerson.Name)
    fmt.Printf("Address: %s\n", getRatsitPerson.Address.StreetAddress)
    fmt.Printf("Postal address: %s %s\n", getRatsitPerson.Address.PostalCode, getRatsitPerson.Address.AddressLocality)
    fmt.Printf("Birth date: %s\n", getRatsitPerson.BirthDate)
    fmt.Printf("Telephone: %s\n", getRatsitPerson.Telephone)
    // If we asked for the person to be added, add it
    if(*addBool) {
      // Check if person already exists with this id
      _, err := fromDB(theDB, ratsitID)
      if(err == nil) {
        fmt.Printf("Person already exists with id %s\n", ratsitID)
      } else {
        doAddRatsit(theDB, ratsitID, getRatsitPerson)
        fmt.Printf("Added person\n")
        fmt.Printf("Recommended next command with arguments -sheets -fix\n")
      }
    }
  }
}
